/*** Copyright 2002, 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.gen;import java.io.*;import java.lang.reflect.*;import glguerin.io.*;import glguerin.util.MacPlatform;// --- Revision History ---// 08Jul2002 GLG  copy GenericForker and eliminate all MRJToolkit calls// 09Dec2002 GLG  move to new package, and revise to be base class for others here// 13Feb2003 GLG  add reflective isHidden()/**** A PlainForker is a Java-only sub-class of FileForker that provides all features using plain Java,** frequently using a java.io.File in the implementation.** All access to resource-forks will return without throwing an exception,** as if the resource-forks were always empty.** Nearly all FileInfo and FileAccess results are faked or ignored.** In particular, setDefaultTypes() has no effect, and getDefaultFileType()** and getDefaultFileCreator() will always return 0.**<p>** This class is useful as a plain and simple cross-platform implementation, and as a base-class.** It has only one static variable that subclasses will share: defaultNameLimit.** That variable is initialized to 255 for all platforms except classical Mac OS,** in which case it's initialized to 31 (MacPlatform.LIMIT_NAME_HFS).**<p>** Many minor elements are missing, constrained, or fictitious** in this implementation: ** file-type, file-creator, Finder flags, when-created, when-modified, ** aliases, alias resolution, file-locking, and file-comments.**<p>** The major elements that are missing, constrained, or fictitious** in this Java-only implementation are:**<ul type="disc">**   <li> resource-forks always have a length of zero, always read as empty,**     and always write as bit-buckets (specifically, as a RandomRWSink).**     </li>****   <li> a getFileInfo() for any non-directory file returns a FileInfo with a**     file-type and creator of 0.**     </li>****   <li> a getFileAccess() fakes up a FileAccess from File.canRead() and File.canWrite().**      The faked owner, group, and public flag-bits are identical to one other.**      The owner and group ID's are both set to FileAccess.ID_UNKNOWN (-1).**     </li>****   <li> setFileInfo(), setFileAccess(), and setComment() do nothing but ensure the file exists**      and is writable.  The test for writability is the fiction used in place of writing file metadata.**     </li>****   <li> setDefaultTypes() does nothing, and getDefaultType() and getDefaultCreator() always return 0.**     </li>****   <li> the alias-resolution methods selfResolve() and makeResolved() use File.getCanonicalPath()**     to perform whatever "resolving" that method performs, since Java has no inherent concept**     of aliases (short-cuts, symbolic links) or alias-resolving.**     </li>****   <li> isAlias() always returns false, as does isSymlink().**     Plain Java has no facility to distinguish or identify symlinks or any other kind of file alias.**     </li>****   <li> methods that may resolve non-leaf aliases on-the-fly will act**     however your platform-specific java.io.File does those things.**     Frequently, symlinks resolve on-the-fly, even if they appear in a leaf.**     </li>**</ul>**<p>** Uses no MRJToolkit calls, hence safe for use in any Cocoa-Java program, which** is sadly not true of the ineptly named GenericForker, which calls MRJToolkit.**** @author Gregory Guerin*/public class PlainForker  extends FileForker{	/** 	** The value of this static field is copied to	** a PlainForker's name-limit at instantiation.	** It also affects PlainForker subclasses, so modify it with discretion.	** Change this value if you want new PlainForker's or its subclasses to have different	** name-limit values.	** This field is initialized with a static initializer	** to either MacPlatform.LIMIT_NAME_HFS or 255, 	** which is usually the right thing to do.	**<p>	** Because this field is a static variable, it's shared among all subclasses.	** So if you use any of PlainForker's subclasses, they will use this value, too.	*/	public static int defaultNameLimit;	static	{		boolean isClassicMac = ( MacPlatform.isMacOS()  &&  MacPlatform.getOSVersion()[ 0 ] < 10 );		if ( isClassicMac )			defaultNameLimit = MacPlatform.LIMIT_NAME_HFS;		else			defaultNameLimit = 255;	}	/** Configured name limit.  */	private final int myNameLimit;	/**	** Vanilla constructor, visible to all.	*/	public	PlainForker()	{  this( defaultNameLimit );  }	/**	** Name-length configuring constructor, visible to all.	*/	public	PlainForker( int nameLimit )	{		super();		myNameLimit = nameLimit;	}	/**	** Return a new File with the name of the current target,	** throwing an IOException if there is no target.	*/	protected File	getTargetFile()	  throws IOException	{		String path = getPath();		if ( path == null  ||  path.length() == 0 )			throw new IOException( "No target" );		return ( new File( path ) );	}	/**	** Invoke getTargetFile(), then see if target exists,	** throwing a FileNotFoundException if it doesn't.	** If the writable flag is clear, no additional testing occurs.	** If the writable flag is set, then the target must also be writable,	** or a different FileNotFoundException is thrown.	** Other IOExceptions may also be thrown.	**<p>	** We don't distinguish between ordinary-file and directory, only	** between existence and non-existence.  That's because a FileForker can	** legitimately target a directory.	*/	protected File	getTargetExisting( boolean writable )	  throws IOException	{		File targetFile = getTargetFile();		if ( ! targetFile.exists() )			throw new FileNotFoundException( "No such file: " + targetFile );		if ( writable  &&  ! targetFile.canWrite() )			throw new FileNotFoundException( "Not writable: " + targetFile );		return ( targetFile );	}	/**	** Invoke getTargetFile(), then check that the target exists.	** If it does, then return the File normally.	** If it doesn't exist and 'create' is clear, throw a FileNotFoundException. 	** If it doesn't exist and 'create' is set, 	** create the target as an ordinary file with a truncating FileOutputStream	** that is immediately closed.  This may cause an IOException or a SecurityException.	** Also calls assignDefault() to set default file-type and creator, but only if file created here.	**<p>	** If the target already exists, do not  truncate or write to it in any way.	**<p>	** If this method returns normally, the target File should definitely exist,	** but you won't know whether it's a file or a directory.	*/	protected File	getTargetExists( boolean create )	  throws IOException	{		File targetFile = getTargetFile();		if ( ! targetFile.exists() )		{			if ( create )			{				// Create the file and assign it the default file-type and creator.				new FileOutputStream( targetFile ).close();				assignDefaults( targetFile );			}			else				throw new FileNotFoundException( "No such file: " + targetFile );		}		return ( targetFile );	}	/**	** Assign default creator and file-type.	** This imp does nothing.	*/	protected void	assignDefaults( File target )	  throws IOException	{  return;  }	/**	** Set the creator and file types that newly created files will have by default.	**<p>	** This imp ignores both values.	*/	public void	setDefaultTypes( int defaultFileType, int defaultFileCreator )	{  return;  }	/**	** Called by makeForkOutputStream() and makeForkRandomRW(),	** or anywhere else a file needs to be created.  NOT called when an existing	** file is merely truncated.	**<p>	** This imp always returns 0.	*/	public int	getDefaultFileType()	{  return ( 0 );  }	/**	** Called by makeForkOutputStream() and makeForkRandomRW(),	** or anywhere else a file needs to be created.  NOT called when an existing	** file is merely truncated.	**<p>	** This imp always returns 0.	*/	public int	getDefaultFileCreator()	{  return ( 0 );  }	/**	** Return any length-limit this implementation imposes on pathname elements.	**<p>	** This implementation returns the value it was created with.	*/	public int	getNameLimit()	{  return ( myNameLimit );  }	// ###  I S O M O R P H S   O F   F I L E   M E T H O D S  ###	/**	** Return true if the current target and all directories leading	** to it exist, false if not.	**	** @see java.io.File#exists	*/	public boolean	exists()	{  		try		{  return ( getTargetFile().exists() );  }		catch ( IOException why )		{ /* FALL THRU */ }		return ( false );	}	/**	** Return true if the current target is an ordinary file (i.e. a non-directory) and all directories leading	** to it exist and are readable, false if not.	** Aliases will return true for this method.	**	** @see java.io.File#isFile	*/	public boolean	isFile()	{  		try		{  return ( getTargetFile().isFile() );  }		catch ( IOException why )		{ /* FALL THRU */ }		return ( false );	}	/**	** Return true if the current target is a directory and all directories leading	** to it exist and are readable, false if not.	** An alias of a directory is not itself a directory, except when java.io.File says it is.	** And that's platform-dependent.	**	** @see java.io.File#isDirectory	*/	public boolean	isDirectory()	{  		try		{  return ( getTargetFile().isDirectory() );  }		catch ( IOException why )		{ /* FALL THRU */ }		return ( false );	}	/**	** Return true if the current target is an alias of some sort, false if not.	**<p>	** This implementation always returns false.	**	** @see glguerin.io.FileInfo#isAlias	*/	public boolean	isAlias()	{  return ( false );  }	/** Will be null if we can't call File.isHidden(), non-null if we can. */	private static Method fileIsHidden;	static	{		try		{			// Load the File class and look for isHidden() method.			// File.isHidden() takes no args, and returns boolean.			// The Class[] represents the method signature (types of the args), which is "no args".			Class<?> fileClass = Class.forName( "java.io.File" );			fileIsHidden = fileClass.getMethod( "isHidden", new Class[ 0 ] );		}		catch ( ClassNotFoundException why )		{  /* FALL THRU */  }		catch ( NoSuchMethodException why )		{  /* FALL THRU */  }		catch ( SecurityException why )		{  /* FALL THRU */  }	}	/**	** Return true if the current target is normally hidden (invisible), false if not.	**<p>	** This implementation uses reflection to call 1.2's File.isHidden() if it can.	** On 1.1, it just checks whether the leaf-name starts with ".".	** Neither test is really very meaningful on Mac OS platforms.	**	** @see glguerin.io.FileInfo#isHidden	*/	public boolean	isHidden()	{  		if ( fileIsHidden == null )		{			// Handles an empty Pathname, representing "/".			// Although "/" is visible, "/." and "/.." are hidden.			String leaf = getLeafName();			return ( leaf != null  &&  leaf.startsWith( "." ) );		}		// The exception-handling is more complex than the actual method-call.		try		{			// Invoke method on target File, get result.			Object result = fileIsHidden.invoke( getTargetFile(), new Object[ 0 ] );			/*			// Simple diagnostic aid...			if ( false )			{  System.out.println( " * PlainForker: File.isHidden(): " + result );  }			*/			// If result is boolean, return the boolean value, else return false.			if ( result instanceof Boolean )				return ( ((Boolean)result).booleanValue() );			else				return ( false );		}		catch ( IOException why )		{			// All IOExceptions return false.			return ( false );		}		catch ( IllegalAccessException why )		{			// Shouldn't happen.			throw new IllegalStateException( "IllegalAccessException: " + why.getMessage() );		}		catch ( InvocationTargetException why )		{			// Return false for underlying IOException.			// Rethrow underlying RuntimeException.			// Everything else is thrown as an IllegalStateException().			Throwable underlying = why.getTargetException();			if ( underlying instanceof IOException )				return ( false );			if ( underlying instanceof RuntimeException )				throw (RuntimeException) underlying;			// I wish there were a RuntimeException that had InvocationTargetException behavior.			throw new IllegalStateException( "Caught InvocationTargetException wrapping: " + underlying.getClass() );		}	}	/**	** Return true if the current target is readable, false if not.	** If the target is a directory, "readable" means that you can list its contents	** and use it in path-names to refer to its contents.	**	** @see java.io.File#canRead	*/	public boolean	canRead()	{  		try		{  return ( getTargetFile().canRead() );  }		catch ( IOException why )		{ /* FALL THRU */ }		return ( false );	}	/**	** Return true if the current target is writable, false if not.	** If the target is a directory, "writable" means that you can create	** or delete files or directories in it.	**	** @see java.io.File#canWrite	*/	public boolean	canWrite()	{  		try		{  return ( getTargetFile().canWrite() );  }		catch ( IOException why )		{ /* FALL THRU */ }		return ( false );	}	/**	** Return the length of the data-fork for false, or the resource-fork for true.	** Always returns zero for directories.	**	** @see java.io.File#length	*/	public long	length( boolean resFork )	{		if ( ! resFork )		{			try			{  return ( getTargetFile().length() );  }			catch ( IOException why )			{ /* FALL THRU */ }		}		return ( 0 );	}	/**	** Return a list of String names representing the named contents of the directory,	** omitting any entries for the targeted directory itself or its parent.	**<p>	** If the target is not a directory, null is returned.	** If the target is an empty directory, a String[0] is returned.	** If the target can't be listed, the result will probably be a String[0]...	**<p>	** The returned array holds names that have undergone a pass through the 	** target Pathname's getFormat().asLiteral(String) method.  That is, all the Strings	** in the array will be literal names immediately suitable for Pathname.add().	** Contrast this with File.list(), where you'd have to call Pathname.addPath() with a name,	** in order to ensure that each name was literalized.	**	** @see java.io.File#list	** @see glguerin.io.Pathname#addPath	** @see glguerin.io.PathnameFormat#asLiteral	*/	public String[]	list()	{		// We get the File.list() and literalize the Strings in-place.		String[] names = new File( getPath() ).list();		if ( names != null )		{			PathnameFormat format = getPathname().getFormat();			for ( int i = 0;  i < names.length;  ++i )			{  names[ i ] = format.asLiteral( names[ i ] );  }		}		return ( names );	}	// ###  D I S K - A L T E R I N G   V A R I A N T S   O F   F I L E   M E T H O D S  ###	/**	** Delete the current target, returning true if successful or false if not.	** If unsuccessful, the reason for failure is unknowable.	** If the target is a directory, it must be empty in order to be deleted.	**	** @see java.io.File#delete	*/	public boolean	delete()	{  		try		{  return ( getTargetFile().delete() );  }		catch ( IOException why )		{ /* FALL THRU */ }		return ( false );	}	/**	** Create the current target as a directory, returning true only if a directory	** was actually created.  Returns false if a directory already exists.	** Throws an IOException if the directory can't be created as requested,	** or if the target item exists but it's not a directory.	**<p>	** Note that an IOException will be thrown if the target item is an alias	** to an existing directory.  End users may find this confusing, since the distinction between	** an actual directory and its alias may not be clear to them.  Thus, you may want to	** resolve aliases or perform other pre-filtering before calling this method.	**	** @see java.io.File#mkdir	*/	public boolean	makeDir()	  throws IOException	{		// Try creating the target.		// If item wasn't created, it must be an existing directory or an IOException is thrown.		boolean created = getTargetFile().mkdir();		if ( ! created  &&  ! isDirectory() )			throw new IOException( "Can't create directory: " + getPath() );		return ( created );	}	/**	** Rename the current target's leaf-item, throwing an IOException on failure.	** when successful, the target's leaf-name becomes the given name.  This differs from java.io.File.	** Also unlike File.renameTo(), this method throws an IOException for errors.	**<p>	** Unlike File.renameTo(), this method will only rename an item without moving it.	** To move an item without renaming it, use moveTo().	** To do both, use both methods.	**	** @see java.io.File#renameTo()	** @see moveTo()	*/	public void	renameLeaf( String newName )	  throws IOException	{  		File target = getTargetFile();		File dest = new File( target.getParent(), newName );		if ( ! target.renameTo( dest ) )			throw new IOException( "Can't rename leaf to: " + dest.getAbsolutePath() );		getPathname().swap( newName );	}	/**	** Move the current target to a new location on the target's volume, throwing an IOException on failure.	** The given destination must be an existing directory or disk-volume.	** If the current target-item is a directory, the entire sub-tree is moved to the new location.	** When successful, the active target will refer to the moved item at its new location.	** This differs from java.io.File.	**<p>	** You can't move items across volumes, only on the same volume.	** To move across volumes, you can use FileHelper.duplicate() to copy items one at a time.	** You can't use this method to rename an item -- use renameLeaf() for that.	**	** @see java.io.File#renameTo()	** @see renameLeaf()	** @see glguerin.io.FileHelper#duplicate()	*/	public void	moveTo( Pathname destination )	  throws IOException	{		File target = getTargetFile();		File dest = new File( destination.getPath() );		// Cover case of moving current target ordinary-file into destination directory.		if ( ! dest.isDirectory() )			throw new IOException( "Destination must be a directory: " + dest.getPath() );		// Actual dest'n is to same name within dest directory.		dest = new File( dest, target.getName() );		if ( ! target.renameTo( dest ) )			throw new IOException( "Can't move to: " + dest.getAbsolutePath() );		getPathname().setFilePath( dest );	}	// ###  F O R K E R   C A T A L O G - I N F O   &   F I L E - A C C E S S  ###	/**	** Get a FileInfo describing the current target <b>WITHOUT</b> resolving any aliases	** that the target may contain.	** If withComment is false, the returned FileInfo will have no comment-bytes.	** If withComment is true, the target's comment-bytes from this.getComment()  	** are attached to the returned FileInfo.  	** Retrieving the comment takes extra time, which may not suit your purposes.	**<p>	** This implementation returns whatever information it can gather from a java.io.File	** object representing the target, and fakes safe default values in	** the FileInfo for everything else.  The file-type and creator are both set to zero.	** A BasicFileInfo is returned, which automatically returns 'fold' type for directories,	** regardless of file-type actually set.	**<p>	** The when-modified and when-created dates are both set from File.lastModified(),	** with when-created artificially placed 13 seconds earlier than when-modified.	** The withComment flag is honored, but there's little point since the corresponding implementation of 	** getComment() does so little.	**<p>	** SecurityManager.checkRead() is invoked to determine if reading is allowed.	**	** @exception java.io.IOException	**    Thrown if the target-item does not exist, or any of the directories leading to it don't exist,	**  or the volume or drive doesn't exist.  Actually throws a FileNotFoundException in those cases.	**  Throws a vanilla IOException if there's any other error while completing the operation.	**	** @see #getComment	*/	public FileInfo	getFileInfo( boolean withComment )	  throws IOException	{		File targetFile = getTargetExisting( false );		boolean isDir = targetFile.isDirectory();		BasicFileInfo info = new BasicFileInfo( isDir, getLeafName() );		// Use the last-modifed time-stamp to set both time-modified and time-created,		// artificially placing creation 13 seconds earlier than time-modified.		// This assumes that File.lastModified() returns the standard mS-since-epoch form,		// a characteristic not guaranteed by the Java Language Spec 1.0 (see sec. 22.24.21).		long when = targetFile.lastModified();		info.setTimeCreated( when - 13000L);		info.setTimeModified( when );		info.setFileType( 0 );		info.setFileCreator( 0 );		if ( ! isDir )		{			info.setForks( targetFile.length(), 0 );		}		if ( withComment )			info.setComment( getComment() );		return ( info );	}	/**	** Set the current target's FileInfo, creating an empty ordinary file if	** the current target-file does not exist.  All directories leading up to the target	** must already exist.	**<p>	** The state of isLocked() in the given info is not applied to the target file.	** To set or clear the file-lock on a target, you must invoke setFileAccess().	**<p>	** If the given FileInfo has a non-zero comment, then the comment is saved	** by calling setComment().	** If the given FileInfo has a zero-length comment, then no comment is saved,	** nor is any existing comment attached to the target file removed.	** To remove a comment from an existing target, you must call setComment()	** with a null or zero-length String.	**<p>	** This implementation does nothing beyond ensuring the file exists.	**<p>	** SecurityManager.checkWrite() is invoked to determine if writing is allowed.	**	** @see #setComment	** @see #setLock	*/	public void	setFileInfo( FileInfo info )	  throws IOException	{  getTargetExists( true );  }	/**	** Return a FileAccess describing the current target's access privileges.	** The exact meaning of the values in the returned FileAccess is platform-dependent.	**<p>	** This implementation returns whatever information it can gather from a java.io.File	** object representing the target, and fills in some plausible default interpretations.	** This is woefully inadequate for anything more than the simplest interpretations.	**<p>	**	** @exception java.io.IOException	**    Thrown if the target-item does not exist, or any of the directories leading to it don't exist,	**  or the volume or drive doesn't exist.  Actually throws a FileNotFoundException in those cases.	**  Throws a vanilla IOException if there's any other error while completing the operation.	*/	public FileAccess	getFileAccess()	  throws IOException	{		File targetFile = getTargetExisting( false );		int flags = 0;		// Fake the READ bits: assume everyone can read.		if ( targetFile.canRead() )			flags |= FileAccess.ACCESS_READ;		// Fake the WRITE bits: assume everyone can write.		if ( targetFile.canWrite() )			flags |= FileAccess.ACCESS_WRITE;		// I'm not even gonna try to fake the EXEC bits.		// The owner and group ID's are faked as the default ID_UNKNOWN.		return ( new FileAccess( flags ) );	}	/**	** Set as much as possible of the current target's access privileges from the given FileAccess	** and the boolean flag.	** The target must already exist; if it doesn't, it is not created, and an IOException is thrown.	**<p>	** The value of isLocked is only used when the FileAccess is null.	** Otherwise the desired state of the file-lock is presumed to be in the non-null FileAccess.	** When the FileAccess is non-null, the boolean is a don't-care.	**<p>	** This implementation does nothing beyond ensuring the file exists.	**<p>	** On Unix platforms, this method could exec the 'chmod' command to change the	** relevant access privileges, though this isn't a terribly speedy approach.	** This is left as an exercise for the interested reader.	*/	public void	setFileAccess( FileAccess desired, boolean isLocked )	  throws IOException	{  getTargetExisting( true );  }	// ###  F O R K E R   F I L E - C O M M E N T S  ###	/**	** Get the comment-text of the current target <b>WITHOUT</b> resolving any aliases	** that the target may contain.	** If the target has no comment, a zero-length String is returned.	** A null is never returned.	**<p>	** This implementation only checks for the existence of the target, and always	** returns a zero-length String if the target exists, or throws an IOException if it doesn't.	**<p>	** SecurityManager.checkRead() is invoked to determine if reading is allowed.	**	** @exception java.io.IOException	**    Thrown if the target-item does not exist, or any of the directories leading to it don't exist,	**  or the volume or drive doesn't exist.  Actually throws a FileNotFoundException in those cases.	**  Throws a vanilla IOException if there's any other error while completing the operation.	*/	public String	getComment()	  throws IOException	{		getTargetExisting( false );		return ( "" );	}	/**	** Set the comment-text of the current target, but DO NOT create the target if it doesn't exist.	** All directories leading up to the target must also exist.	**<p>	** This implementation only checks for the existence of the target, and 	** throws an IOException if it doesn't exist.	**<p>	** SecurityManager.checkWrite() is invoked to determine if writing is allowed.	*/	public void	setComment( String comment )	  throws IOException	{  getTargetExisting( true );  }	// ###  R E S O L V I N G   A L I A S E S  ###	/**	** For the current target, resolve all aliases contained therein and	** return a new Pathname whose parts name the actual unaliased volume,	** folders, and file of the original item.	**<p>	** In this implementation, the current target must exist.	** The contract declared by FileForker says that the target need not exist	** but all the items leading up to it must.	** Since this implementation uses only File methods, it's not possible to provide the	** precise FileForker contract, since getCanonicalPath() may fail on nonexistent targets.	** Also, since getCanonicalPath() may decide to return an absolute path on nonexistent targets,	** there is a possibility that the returned Pathname may refer to a nonexistent target.	** You'd only discover this when you tried to do something in the file-system.	** Ideally, this method should have thrown an exception, but it can't for the reasons above.	**<p>	** If any resolvable alias resides on an AppleShare server, the resolution process may attempt 	** to mount that server.  This may result in a timeout if the server cannot be found (usually about 15 secs),	** during which the computer may be unresponsive to the user.		**<p>	** This implementation simply replicates the current Pathname's File target,	** after ensuring that the target exists.  	** This does not quite result in the required behavior, so this implementation is lame.	**<p>	** Resolving aliases typically requires reading the file-system.	*/	public Pathname	makeResolved()	  throws IOException	{		// A non-existent File target may return the absolute path or throw an IOException.		// The exact behavior is undefined.  If we get an IOException, that's fine.		// If we get an absolute path, that'll work too, since we just make a new Pathname from it.		// Subsequent file-system operations on the new Pathname may fail, 		// but that's left for subsequent operations to determine at that time.		String canonical = getTargetFile().getCanonicalPath();		Pathname resolved = new Pathname( 1, getPathname().getFormat() );		resolved.setPath( canonical );		return ( resolved );	}	// ###  F O R K E R   I / O - F A C T O R I E S  ###	/**	** This implementation returns a faked zero-length InputStream if resFork is set,	** or a readable InputStream if resFork is clear.	** The target-file must exist, even if for a faked resource-fork.	**<p>	** This imp calls makeForkRandomRW().	*/	public InputStream	makeForkInputStream( boolean resFork )	  throws IOException	{  return ( new RandomRWInputStream( makeForkRandomRW( resFork, false ) ) );  }	/**	** Return a faked bit-bucket OutputStream if resFork is set, 	** or a FileOutputStream if resFork is clear.	** The target-file will exist, even though a resource-fork OutputStream will not write	** anything to it.	*/	public OutputStream	makeForkOutputStream( boolean resFork, boolean append )	  throws IOException	{		if ( resFork )			return ( new RandomRWOutputStream( makeForkRandomRW( resFork, true ) ) );		else			return ( new FileOutputStream( getPath(), append ) );	}	/**	** Return a RandomRWFile when resFork is false (data-fork),	** or a RandomRWSink when resFork is true (resource-fork).	** Throws an IOException if readWrite is false and target doesn't exist.	*/	public RandomRW	makeForkRandomRW( boolean resFork, boolean readWrite )	  throws IOException	{		// For this method:		//   resFork F, readWrite F :: target must exist, file opened for reading		//   resFork T, readWrite F :: target must exist, sink used for reading		//   resFork F, readWrite T :: target will be created, file opened for writing		//   resFork T, readWrite T :: target will be created, sink used for writing		getTargetExists( readWrite );		if ( resFork )			return ( new RandomRWSink() );		else			return ( new RandomRWFile( getPath(), readWrite ) );	}}