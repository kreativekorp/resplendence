/*** Copyright 2001, 2002 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.ten;import java.io.*;import com.apple.mrj.macos.carbon.CarbonLock;import com.apple.mrj.internal.jdirect.TerminationListener;import com.apple.mrj.internal.jdirect.TerminationServices;import glguerin.io.*;import glguerin.io.imp.mac.*;// --- Revision History ---// 21Jun01 GLG  create// 05Jul01 GLG  add flush() override// 03Dec2002 GLG  FIX: embed literal Carbon framework-name here for Linker/**** FSFork10 is a ForkRW that uses the FSRef APIs under Carbon on Mac OS X.**<p>** I'm not sure whether forks must be closed manually at termination.** I'm doing it anyway because it just seems safer that way.**** @author Gregory Guerin*/public final class FSFork10  extends ForkRW  implements TerminationListener{    public static final String 		JDirect_MacOSX = "/System/Library/Frameworks/Carbon.framework/Versions/A/Carbon";	private static Object linkage = new com.apple.mrj.jdirect.Linker( FSFork10.class );	/**	** Only constructor.	*/	public	FSFork10( boolean forWriting, int forkRefNum, String tag )	{		super( forWriting, forkRefNum, tag );		TerminationServices.addListener( this );	}	/**	** As a TerminationListener, this method closes the fork using forceClose().	** This instance is added as a listener when it's opened successfully, then	** removed as a listener after closing.  Thus, the only listeners that remain at exit()	** are the ones still having open forks.	*/	public void 	terminate()	{		try		{  forceClose();  }		catch ( IOException why )		{ /* IGNORED */ }	}	/**	** Flush anything internally buffered to disk.	*/	public void 	flush()	  throws IOException	{		short refNum = refOK();		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSFlushFork( refNum );			}			finally			{  CarbonLock.release();  }		}		checkIO( osErr );	}	/**	** Return the length of the given refNum's fork, or throw an IOException.	*/	protected int	forkLength( short refNum, long[] length )	{		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSGetForkSize( refNum, length );			}			finally			{  CarbonLock.release();  }		}		return ( osErr );	}	/**	** Return the current R/W position of the given refNum's fork, or throw an IOException.	*/	protected int	forkAt( short refNum, long[] position )	{		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSGetForkPosition( refNum, position );			}			finally			{  CarbonLock.release();  }		}		return ( osErr );	}	/**	** Seek to the given position in the given refNum's fork, or throw an IOException.	** The position is always relative to the beginning of the file.	*/	protected int	forkSeek( short refNum, long position )	{		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSSetForkPosition( refNum, (short) 1, position );					// posMode 1 = fsFromStart			}			finally			{  CarbonLock.release();  }		}		return ( osErr ); 	}	/**	** Set the length of the given refNum's fork, or throw an IOException.	** When extended, the new bytes in the fork may contain arbitrary	** and possibly sensitive data from reused disk blocks.	*/	protected int	forkSetLength( short refNum, long length )	{		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSSetForkSize( refNum, (short) 1, length );					// posMode 1 = fsFromStart			}			finally			{  CarbonLock.release();  }		}		return ( osErr ); 	}	/**	** Read bytes from the current position in the given refNum's fork,	** for a byte-count given by requestCount, placing the bytes in the buffer	** beginning at offset 0.	** Return the actual byte-count read in actualCount[ 0 ].	*/	protected int	forkRead( short refNum, byte[] buffer, int requestCount, int[] actualCount )	{		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSReadFork( refNum, (short) 0, 0L, requestCount, buffer, actualCount );					// posMode 0 = kFSAtMark, offset = ignored.			}			finally			{  CarbonLock.release();  }		}		return ( osErr ); 	}	/**	** Write bytes to the current position in the given refNum's fork,	** for a byte-count given by requestCount, taking the bytes from the buffer	** beginning at offset 0.	*/	protected int	forkWrite( short refNum, byte[] buffer, int requestCount, int[] actualCount )	{  //		actualCount[ 0 ] = requestCount;		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSWriteFork( refNum, (short) 0, 0L, requestCount, buffer, actualCount );					// posMode 0 = kFSAtMark, offset = ignored.			}			finally			{  CarbonLock.release();  }		}		return ( osErr ); 	}	/**	** Close the given refNum.	*/	protected int	forkClose( short refNum )	{  		int osErr;//		synchronized ( Carbonate.LOCK )		{			try			{				CarbonLock.acquire();				osErr = FSCloseFork( refNum );			}			finally			{  CarbonLock.release();  }		}		TerminationServices.removeListener( this );		return ( osErr ); 	 }	// ###  J D I R E C T - 3   F U N C T I O N   B I N D I N G S  ###	/** xx */	private static native short 	FSFlushFork( short refNum );	/** xx */	private static native short 	FSCloseFork( short refNum );	/** xx */	private static native short 	FSReadFork( short refNum, short posMode, long offset, int request, byte[] buffer, int[] got );	/** xx */	private static native short 	FSWriteFork( short refNum, short posMode, long offset, int request, byte[] buffer, int[] got );	/** xx */	private static native short 	FSGetForkSize( short refNum, long[] longRef );	/** xx */	private static native short 	FSSetForkSize( short refNum, short posMode, long position );	/** xx */	private static native short 	FSGetForkPosition( short refNum, long[] longRef );	/** xx */	private static native short 	FSSetForkPosition( short refNum, short posMode, long position );}