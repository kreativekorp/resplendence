/*** Copyright 1998, 1999, 2001 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac;import java.io.*;import glguerin.io.*;// --- Revision History ---// 18Jun01 GLG  create stub subclass// 04Jul01 GLG  cut boolean arg from refRoot()// 04Dec2002 GLG  cut exists()// 17Jan2003 GLG  add mayResolve()/**** An FSSpecItem is an FSItem that uses the FSSpec-based API under** Classic Mac OS.  It will not work as-is on FSSpec-based Mac OS X, since** the pathname semantics are different on Mac OS X.**** @author Gregory Guerin*/abstract public class FSSpecItem  extends FSItem{	/** My primary FSSpec, used for all operations. */	protected FSSpec mySpec;	/** My secondary FSSpec, used only for moveTo(). */	protected FSSpec mySpec2;	/** My CatalogAccess. */	protected final CatalogAccess myCatInfo;	/** My CommentAccess. */	protected final CommentAccess myCommentor;	/**	** Construct an empty FSSpecItem.	*/	protected	FSSpecItem()	{  		super();		mySpec = newFSSpec();		mySpec2 = newFSSpec();		myCatInfo = newCatalogAccess();		myCommentor = newCommentAccess();	}	/** Make a concrete FSSpec. */	abstract protected FSSpec	newFSSpec();	/** Make a concrete CatalogAccess. */	abstract protected CatalogAccess	newCatalogAccess();	/** Make a concrete CommentAccess. */	abstract protected CommentAccess	newCommentAccess();	/**	** Return any length-limit this implementation imposes on pathname elements.	** This represents a limit on Pathname part Strings, not a limit on overall pathname length.	*/	public int	nameLimit()	{  return ( 31 );  }	/**	** Set this FSItem so it references the root item for the given Pathname,	** returning the index of the Pathname part	** whose String should first be passed to refItem().	*/	protected int	refRoot( Pathname path )	  throws IOException	{		// An empty Pathname should pretend to be a read-only directory of		// the current list of mounted volume names.		if ( path.count() == 0 )			throw new UnsupportedIOException( "Empty Pathname" );		// Point mySpec at the volume part of the Pathname.		// FSSpec semantics require a trailing ':' on a naked volume-name.		mySpec.set( 0, 2, path.part( 0 ) + ":" );		// Remainder of path starts at index of 1.		return ( 1 );	}	/**	** Set this FSItem so it references the named item relative to its current reference,	** resolving aliases as requested.	*/	protected void	refItem( String part, boolean resolveAliases )	  throws IOException	{		// The current mySpec contents is used as a directory (container) enclosing the named item.		myCatInfo.setTarget( mySpec );		myCatInfo.fill();		// If it's not a directory and we should attempt to resolve it, do so.		if ( ! myCatInfo.isDirectory()  &&  mayResolve() )		{			int result = mySpec.resolve();			if ( result == FSSpec.RESOLVED )			{				// If an alias was resolved, must get its info in myCatInfo.				myCatInfo.setTarget( mySpec );				myCatInfo.fill();			}		}		// At this point, myCatInfo holds info of a dir, an alias's original referent, or a file.		// Get the referent's own dirID (or fileID) in order to set mySpec to the named item.		int vol = myCatInfo.getVRefNum();		int dirID = myCatInfo.getIODirID();		// Set mySpec according to semantic meaning of given part-name,		// and resolve leaf aliases as requested.		mySpec.set( vol, dirID, semantically( part ) );		if ( resolveAliases )			mySpec.resolved();	}	/**	** Called by refItem().	** On entry, myCatInfo references an "apparent" directory, symlink, or alias-file.	** Return T if caller should attempt to resolve it, F if not.	**<p>	** An implementation may always return T, always return F, or	** evaluate myCatInfo to return T or F.	** An imp that always returns T will	** always resolve non-leaf symlinks and aliases.	** An imp that always returns F will only resolve symlinks and aliases	** when refItem() is called with resolveAliases of T.	** An imp that evaluates myCatInfo will resolve non-leaf symlinks but not aliases,	** or vice versa, or whatever myCatInfo is evaluated for.	**<p>	** An implementation of this method may use myCatInfo but must not change it.	** It may use or change mySpec.	*/	abstract protected boolean	mayResolve();	/**	** An internalFormat()'ed pathname may nonetheless contain semantic references like "." or "..".	** We have to treat these semantically, and provide classical Mac OS representations.	** Note that escaping or other encoding has already been removed, so only semantics are applied.	*/	protected String	semantically( String internalPart )	{		if ( ".".equals( internalPart ) )			return ( ":" );		if ( "..".equals( internalPart ) )			return ( "::" );		return ( internalPart );	}	/**	** Fill in the given Pathname with the names referencing this FSItem.	** That is, do the opposite of the most recent call to reference().	** If the most recent reference() resolved aliases, then the given Pathname	** is filled in with the names leading to the resolved original item.	*/	public void	resolved( Pathname path )	  throws IOException	{		// This FSItem must be valid, and Pathname empty.		valid();		path.clear();		// Fill myCatInfo with info about the current target, but ignore IOExceptions.		// The leaf may not exist, but all dirs leading to it must.		try		{  getInfo( false );  }		catch ( IOException why )		{  /* OK, fall through to loop. */  }		// At loop entry and each iteration, myCatInfo holds the volRefNum, dirID, and leaf name		// of an item.  At entry, the named leaf might not exist, but all the leading directories do.		// We have to keep reusing the volRefNum as we ascend to the root.		int vol = mySpec.getVRefNum();		for (;;)		{			// At this point, myCatInfo's leaf-name is a literal name.			// Add it to the Pathname literally.			path.add( myCatInfo.getLeafName() );				int dir = myCatInfo.getParentDirID();			if ( dir < 2 )				break;				// the dir will be < 2 only after we've filled myCatInfo with info from				// the root-dir of a volume, whose leaf-name will be the vol-name.				// A volume's root-dir always has a DirID of 2.			myCatInfo.setTargetWhat( vol, dir, -1 );			myCatInfo.fill();		}		// The parts were added starting with leaf, so reverse them.		path.reverse();	}	/**	** Create the current target (both forks), throwing an IOException if problematic,	** and returning true if the target was actually created as requested.	** If the target already exists, the existing item is left as-is and false is returned	** -- no IOException is thrown.  This happens even if the requested item is	** not the same kind as the existing item (directory vs. file).	**<p>	** If the target is indeed created, this FSItem continues to refer to that target,	** even if creating the target changes some internal data.	*/	public boolean	create( int defaultType, int defaultCreator, boolean isDirectory )	  throws IOException	{		valid();		return ( mySpec.create( defaultType, defaultCreator, isDirectory ) );	}	/**	** Open the designated fork for the designated access.	** The target file must already exist.	** No existing fork is truncated or altered, even if opened for writing.	** It's up to the implementation to decide if multiple ForkRW's can be open	** for writing to the same file at once.  The canonical Mac OS behavior is	** to forbid multiple writers, but to allow any number of non-exclusive readers.	*/	public ForkRW	openFork( boolean resFork, boolean forWriting )	  throws IOException	{		valid();		int refNum = mySpec.openFork( resFork, forWriting );		String tag = mySpec.getName() + (resFork ? "(RF)" : "(DF)" );		return ( newFork( forWriting, refNum, tag ) );	}	/**	** If this FSItem refers to a directory, assemble its direct (non-recursive)	** contents as a list of names to the given Pathname, which is cleared first.	** Any names for the directory itself or its parent are omitted.	** Only the direct contents is listed, which is not a recursive list.	** The Pathname is used only as a list of Strings, not as an actual Pathname.	** This method does not clear the Pathname before adding names to it.	**<p>	** The names are not added in any particular order.  Do not assume they are sorted.	**<p>	** If this FSItem refer to a non-directory or a non-existent item,	** an IOException may be thrown, so you should first qualify the call to this method.	**<p>	** If we were doing something more to a directory than just listing it,	** an Enumeration would be more appropriate.  Since all we ever want is a	** list of names, a single method that does only that is appropriate.	*/	public void	contents( Pathname collecting )	  throws IOException	{		valid();		collecting.clear();		if ( getInfo( false ).isDirectory() )		{			// Getting here, mySpec and myCatInfo reflect the target, which is a directory to list.			int vol = myCatInfo.getVRefNum();			int dir = myCatInfo.getIODirID();		// the dirID of the target itself, not its parent.			// The loop is terminated when myCatInfo.fill() throws any IOException.			// In theory, only a FileNotFoundException indicates normal end, but since we can't			// do anything useful for the other IOExceptions, just catch and ignore them, too.			try			{				// We use internalFormat() to literalize each name collected.				// In practice, this is a waste since the names in myCatInfo are already literal.				// Still, this is a reminder for future implementations that literalizing needs to happen.//				PathnameFormat format = internalFormat();				for ( int i = 1;  true;  ++i )				{					// Get info on the next sequential item.					myCatInfo.setTargetWhat( vol, dir, i );					myCatInfo.fill();					// Omit items named "." and ".." to prevent semantic confusion.					String name = myCatInfo.getLeafName();					if ( ".".equals( name )  ||  "..".equals( name ) )						continue;					// Add literal name, which is what myCatInfo holds as leaf name.					collecting.add( name );				}			}			catch ( IOException ignored )			{  /* IGNORED -- signals normal end of directory scan */  }		}	}	/**	** Return either the brief or full form of a FileInfo.	** The returned FileInfo should not be altered nor retained,	** since it is probably a singleton internal reference.	** That is, if you want the information to persist, copy it somewhere else.	**<p>	** The brief form returns a FileInfo where only isDirectory(), isAlias(), isLocked(),	** Finder-flags, and fork-lengths are valid.  In particular, neither leaf-name,	** nor file-type, nor creator, nor any of the time-stamps are guaranteed to be valid.	**<p>	** The full form DOES NOT include the comment, which is always separately accessed.	*/	public FileInfo	getInfo( boolean full )	  throws IOException	{		valid();		myCatInfo.setTarget( mySpec );		myCatInfo.fill();		return ( myCatInfo );	}	/**	** Set the file info.	** The target must exist, but can be a file or a directory.	** Some elements of directories are unsettable, such as file-type and creator.	*/	public void	setInfo( FileInfo info )	  throws IOException	{		valid();		// Copy the desired FileInfo into myCatInfo, clearing it first.		// If info.isDirectory() was true, that state IS NOT COPIED to myCatInfo.		myCatInfo.copyFrom( info );		// Assume mySpec refers to the target, which must exist.		// Target myCatInfo using the data in mySpec, but retaining all the other		// contents previously copied into place by copyFrom().		myCatInfo.setTarget( mySpec );		myCatInfo.write();	}	/**	** Get a new FileAccess representing the access privileges.	** In this FSSpec-based implementation, the READ access privileges are always set.	** The WRITE access privileges are set when the file is unlocked, and clear when the file is locked.	** The IS_LOCKED privilege reflects the file-lock state.	** All other privileges are clear.	** The owner and group ID are the default: FileAccess.ID_UNKNOWN.	*/	public FileAccess	getAccess()	  throws IOException	{		valid();		// Fake all the WRITE access privileges based on the file-lock alone.		// If lock is clear, all WRITE access is granted and IS_LOCKED is clear.		// If lock is clear, all WRITE access is denied and IS_LOCKED is set.		int privileges;		if ( getInfo( false ).isLocked() )			privileges = FileAccess.IS_LOCKED;		else			privileges = FileAccess.ACCESS_WRITE;		// Classically speaking, all READ access is always available.		return ( new FileAccess( privileges | FileAccess.ACCESS_READ ) );	}	/**	** Set as much of the given FileAccess as possible.	** In this FSSpec-based implementation, on the IS_LOCKED privilege is used.	** All other privilege bits are don't-cares.	** The owner and group ID's are also don't-cares.	*/	public void	setAccess( FileAccess desired, boolean isLocked )	  throws IOException	{		// A non-null FileAccess supercedes a boolean flag.		if ( desired != null )			isLocked = desired.has( FileAccess.IS_LOCKED );		valid();		mySpec.setFileLock( isLocked );	}	/**	** Delete the current target, throwing an IOException if problematic.	** The target must already exist.	** If the target is a directory, it must be empty.	** If the target is a file, both forks are deleted.	*/	public void	delete()	  throws IOException	{		valid();		mySpec.delete();		invalid();	}	/**	** Rename the referenced item, throwing an IOException if problematic.	** The current item must already exist and no item with newName can exist.	** The newName is taken as a literalized name suitable for add()'ing to a Pathname.	*/	public void	rename( String newName )	  throws IOException	{		valid();		mySpec.rename( newName );		invalid();	}	/**	** Move the currently referenced item to the destination Pathname directory.	** The current item must already exist, and no item of the same name can exist	** in the destination directory.  The destination must be an existing directory.	** On success, this FSItem will be an invalid reference.	*/	public void	moveTo( Pathname destination )	  throws IOException	{		// Do validation and existence test for original reference.		// An IOException is thrown if this is an invalid FSItem or target is non-existent.		getInfo( false );		// Since mySpec holds original reference, we swap it with mySpec2.		// We can leave the FSSpec's swapped upon return., since they are interchangeable.		FSSpec temp = mySpec;		mySpec = mySpec2;		mySpec2 = temp;		// This try block ensures that invalid() is called no matter whether we		// complete normally or have an IOException or an early return.		try		{			// Now reference() the destination Pathname, which must be an existing directory.			reference( destination, false );			if ( ! getInfo( false ).isDirectory() )				throw new IOException( "Destination must be a directory: " + destination );			// At this point, mySpec references the destination directory, and			// mySpec2 references the original item, i.e. the item to move.			mySpec2.moveTo( mySpec );		}		finally		{			// Always leave this in invalid state, since it internaly refers to			// the original item in its original location.			invalid();		}	}	/**	** Get the comment, or return an empty String.	** Never returns null.	**<p>	** If the implementation does not support comments, this method 	** may always return an empty String, never throwing an IOException.	*/	public String	getComment()	  throws IOException	{		valid();		myCommentor.setTarget( mySpec );		return ( new String( myCommentor.getCommentBytes() ) );	}	/**	** Set or remove the current target's comment.  	** If comment is null or zero-length, any existing comment is removed.	** If comment is 1 or more bytes, the comment is set.	**<p>	** If the implementation does not support comments, this method 	** may have no effect but still not throw an IOException.	*/	public void	setComment( String comment )	  throws IOException	{		valid();		myCommentor.setTarget( mySpec );		byte[] bytes = null;		if ( comment != null )			bytes = comment.getBytes();		myCommentor.writeComment( bytes );	}}