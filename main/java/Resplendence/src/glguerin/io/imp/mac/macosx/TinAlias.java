/*** Copyright 2002, 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.macosx;import glguerin.io.*;/**** TinAlias is the FileForker.Alias for MacOSXForker.** It maintains an AliasHandle internally, in addition to a Pathname** and a couple of FileInfo's.**<p>** <b>NOTES ON 64-BITNESS</b>**<p>** As of March 2006, there is no 64-bit JVM on Mac OS X.  When there is one, read this.**<p>** The JNI code may accept and return pointers that have been "type-punned" into Java types.** As of March 2006, the Java type used is int, which is 32-bits.** In order for this Java code to work with a 64-bit native library, the type-punned pointers** will have to be converted to a Java long, and corresponding changes made to the C code.** It's not just a matter of changing arg types and return types.** You'll also have to change some array-copies from Get/SetIntArrayRegion() to Get/SetLong...**<p>** Type-punned pointers are currently used by this class in only one area:  ** AliasHandles.  **<p>** The AliasHandle is stored in a 32-bit int (aliasHand).** That field, and all the code dealing with it, would have to use a Java long instead.** This includes (but is not limited to) getAliasHandle(), getAliasHandleData(), ** along with the native methods.**<p>** I don't think there are any other type-punned pointers used in this class or its C code.** However, I didn't exhaustively bench-check, and more to the point, there isn't a 64-bit** JVM I can target on Mac OS X, so this is all just speculative until we can run real code.**** @author Gregory Guerin*/public class TinAlias  extends FileForker.Alias{	// ## Rely on MacOSXForker to load JNI library that has my native functions in it.	private int aliasHand;  // actually a type-punned C pointer used by TinFSRefItem	private FileInfo targetInfo, aliasInfo;	private String pathStr;	/**	** Create as destroyed, empty, and unusable.  This is purely a kluge for outsiders.	*/	protected	TinAlias()	{  super();  }	/**	** This is the useful constructor.  Not accessible outside package or subclasses.	** The Pathname and FileInfo's are	** always unshared instances, which this Alias can keep and modify.	*/	protected	TinAlias( int aliasHandle, Pathname path, FileInfo targetInfo, FileInfo aliasInfo )	{		super();		aliasHand = aliasHandle;		this.targetInfo = targetInfo;		this.aliasInfo = aliasInfo;		pathStr = path.getPath();	}	/** Return assigned AliasHandle, masquerading as an 'int'. */	protected int	getAliasHandle()	{  return ( aliasHand );  }	/**	** Create an array of icon-hints, with an empty slot at [0] for	** TinFSRefItem.createAliasFile() to return a value.	**<br> iconHints[0]: empty slot	**<br> iconHints[1]: creator-hint or 0	**<br> iconHints[2]: type-hint or 0	**<p>	** Current status: no hints in returned array.	** Icon Services functions called in TinFSRefItem.createAliasFile()'s	** native code suffices for Mac OS 10.2 and 10.1.	** It will probably suffice for 10.0, too, but need a different Icon Services function-call.	*/	protected int[]	makeIconHints()	{		int[] hints = new int[ 3 ];		return ( hints );	}	/**	** Sets result's filetype and creator, but not its Finder-flags or any other field.	** If destroy()'ed, then result is unchanged.	*/	protected void	mapAliasInfo( FileInfo result )	{		// If aliasInfo was assigned, use its type and creator exactly as given.		FileInfo info = aliasInfo;		if ( info != null )		{			result.setFileType( info.getFileType() );			result.setFileCreator( info.getFileCreator() );			return;		}		// Getting here, we have to map original's info into an alias-type.		// By default: result has same type & creator as original.		info = targetInfo;		if ( info == null )			return;		result.setFileType( info.getFileType() );		result.setFileCreator( info.getFileCreator() );		// Treat all originals that are directories as folders, never as bundles.		if ( info.isDirectory() )		{			result.setFileType( 0x66647270 );  // 'fdrp'			result.setFileCreator( FileInfo.OSTYPE_MACOS );  // 'MACS'		}		else if ( info.getFileType() == 0x4150504C )  // an 'APPL'-type file		{			// Classical applications have file-type 'adrp', creator = app-signature.			result.setFileType( 0x61647270 );  // 'adrp'		}	}	/**	** Return the platform-dependent pathname of the original referent,	** in a form appropriate for a java.io.File or a suitably platform-aware Pathname.	** Initially, this is the value of getPath() of the FileForker at the time the	** Alias was made by makeAlias().	**<p>	** Returns null after destroy().	*/	public String	originalPath()	{  return ( pathStr );  }	/**	** Return an identifying value representing the type of this Alias.	** The value may legitimately be zero, even when the implementation supports file-types.	** Certain specific values have meanings	** as described for the OSTYPE_XXX named constants in this class.	**<p>	** Returns -1 after destroy().	*/	public int	getAliasType()	{		// Create a temporary FileInfo, with -1 as file-type.		FileInfo result = new BasicFileInfo( false, "" );		result.setFileType( -1 );		mapAliasInfo( result );		return ( result.getFileType() );	}	/**	** Return a set of bits, signifying capabilities, in an int.	**<p>	** This imp can make alias-files and symlinks, so return	** CAN_ALIAS_FILE | CAN_SYMLINK.	*/	public int	getCapabilities()	{  return ( CAN_ALIAS_FILE | CAN_SYMLINK );  }	/**	** Destroy all the internal elements of this Alias, making it unusable.	** Calling destroy() more than once on the same Alias is always harmless.	**<p>	** The number and kind of internal resources for an Alias is implementation-dependent.	** You can call this method to speed up the freeing of an Alias's internal resources.	** This would be wise if you're creating lots of Alias'es and the GC'er isn't working fast enough.	*/	public void	destroy()	{		pathStr = null;		targetInfo = aliasInfo = null;		int hand = aliasHand;		aliasHand = 0;		if ( hand != 0 )			freeHand( hand );		return;	}	/**	** Return the contents of the internal aliasHand, or null if destroyed.	** Protected visibility, so package outsiders need reflection and AccessibleObject to invoke.	*/	protected byte[]	getAliasHandleData()	{		byte[] bytes = null;		int hand = aliasHand;		if ( hand != 0 )		{			int len = getHandleSize( hand );			if ( len >= 0 )			{				bytes = new byte[ len ];				getHandleData( hand, bytes, 0, len );			}		}		return ( bytes );	}	// ###  J N I   F U N C T I O N   B I N D I N G S  ###	/**	 * @return  size, always less than 2 GB; or negative error-code	## int getHandleSize( int anyHand );	 */	private static native int		getHandleSize( int anyHand );	/**	 * @return  result-code	## int getHandleData( int anyHand, byte[] bytes, int offset, int count );	 */	private static native int		getHandleData( int anyHand, byte[] bytes, int offset, int count );	/**	 * @return  result-code	 */	private static native int		freeHand( int aliasHand );}