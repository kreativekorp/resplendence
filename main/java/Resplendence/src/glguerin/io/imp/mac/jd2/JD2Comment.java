/*** Copyright 1998, 1999, 2001 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.jd2;import java.io.IOException;import java.io.FileNotFoundException;import java.util.Hashtable;import com.apple.mrj.macos.toolbox.Toolbox;import glguerin.io.*;import glguerin.io.imp.mac.*;// --- Revision History ---// 29Mar99 GLG  first version// 30Mar99 GLG  add "remove-comment" logic// 01Apr99 GLG  change synchronization-point in findDTRefNum()// 05Apr99 GLG  expand doc-comments// 13Apr99 GLG  revise to implement CommentAccess// 14Apr99 GLG  add doc-comments, remove old junk// 26Apr99 GLG  cover some name changes// 29Apr99 GLG  add Toolbox.LOCK code// 03May99 GLG  fix bug in writeComment() of trying to remove non-existent comment// 28Oct99 GLG  fix: getCommentBytes() sets ioDTReqCount before doing PBDTGetCommentSync() // 07May01 GLG  revise to use DTAccess and reworked CatalogAccess// 05Jun01 GLG  FIX: make writeComment() limit length correctly// 12Jun01 GLG  FIX: cut DTAccess cache support; can't maintain coherency with OS volume mounting// 12Jun01 GLG  cut getDTRefNum(), replacing with internal-only prepVol()// 03Jul01 GLG  FIX: make getCommentBytes() consider fnfErr to be No Error/**** A CommentAccessor is a concrete implementation of CommentAccess.**<p>** This class provides shared access to the desktop database identifiers known as** DTRefNum's.  The static method FindDTRefNum() will use a known ID if it finds it in its cache,** or it will create a cached entry for now and later.**<p>** The Apple reference materials I used to build this class are:**<ul type="disc">**   <li> <i>Inside Macintosh: More Macintosh ToolBox</i><br>**    Chapter 9 covers everything about the desktop database.**    I used PBDTGetPath(), PBDTGetCommentSync(), PBDTSetCommentSync(), **    PBDTRemoveCommentSync(), and PBDTFlushSync().**    If you're daring, you can try rewriting this class with everything done asynchronously.**</ul>**** @author Gregory Guerin*/public class JD2Comment  extends JD2Hand  implements CommentAccess{	/*	** A singleton CommentAccess instance used to translate VolRefNums into DTRefNums.	*/	private static JD2Comment dtAccess = new JD2Comment();	// ###  I N S T A N C E   M E T H O D S  ###	private String name = "";	/**	** Override Object.toString(), returning the name.	** The returned String may be zero-length, but should never be null.	*/	public String	toString()	{  return ( name );  }	/**	** Create an empty instance, also creating an internal handle of proper size.	*/	public	JD2Comment()	{  super( SIZE );  }	// ###  A C C E S S O R S  ###	/**	** Clear the instance, then set the internal fields from the given values.	** An implementation must internally translate the volRefNum into a DTRefNum.	*/	public void 	setTarget( FSSpec spec )	{		prepVol( (short) spec.getVRefNum() );		setIntAt( DIR_ID_AT, spec.getParentDirID() );  		name = spec.getName();		setBytesAt( NAMEBUF_AT, NameString.toPStr( name, IONameStr - 1 ) );	}	/**	** Clear and prepare the struct with the given volRefNum and its corresponding DTRefNum.	** On failure, the volRefNum will be correct, but the DTRefNum will be zero.	*/	private void	prepVol( short volRefNum )	{		eraseAll();		setShortAt( VREFNUM_AT, volRefNum );		// This block tries to determine a DTRefNum corresponding to the volRefNum.		// On success, the DTRefNum will be stored at its proper place in the struct.		// On failure, zero will be stored there instead of a DTRefNum.		try		{  			int pbPtr = lockedPointer();			setIntAt( NAMEPTR_AT, pbPtr + NAMEBUF_AT );				synchronized ( Toolbox.LOCK )			{				// On failure, always ensure that DTRefNum is zero.				// It will be, according to the API, but be certain anyway.				if ( PBDTGetPath( pbPtr ) != 0 )					setShortAt( DTREFNUM_AT, (short) 0 );			}		}		finally		{  unlock();  }		// Always ensure that volRefNum is ready for additional DT calls.		setShortAt( VREFNUM_AT, volRefNum );	}	// ###  O P E R A T O R S  ###	/**	** Call PBDTGetComment() using current struct's data,	** throwing an IOException on errors.	** If no comment exists for the target item, a zero-length byte[] is returned.	** This method does not distinguish between non-existent targets and	** targets that lack a comment.  Both return a zero-length byte[].	**<p>	** Though Inside Macintosh doesn't say so, ioDTReqCount is an input arg that	** indicates a limit to the number of comment-bytes desired, i.e. effectively	** the length of the comment-text buffer.	** The HFS file-system ignores this, always returning the entire comment, up	** to its own inherent limit of 200 bytes.	** AppleShare, among others, respects the length, and will truncate as necessary.	** Apparently, Mac OS 8.6 also now respects the length at all times (even with HFS),	** which is what caused	** my latent defect to appear (I was zeroing ioDTReqCount) and this fix to be added.	** My thanks to Giuliano Gavazzi of humph.com for pointing me at "MoreDesktopMgr.c",	** where I found the relevant inadequately documented "important notes".	**<p>	** Also recall that I increased the size of CommentAccess.CommentText to be 256 bytes.	** This ensures that I won't get killed if some file-system decides to ignore the ioDTReqCount	** arg and store up to 256 bytes in the internal buffer.	** More than 256 bytes and we're road-kill, though.	*/	public byte[]	getCommentBytes()	  throws IOException	{		byte[] text = FileForker.NO_BYTES;		// If the DTRefNum is zero, then pretend there's no comment (and no error).		if ( getShortAt( DTREFNUM_AT ) != 0 )		{			try			{  				// Ironic how it takes one line of code, but several paragraphs to explain why.				setIntAt( DTREQCOUNT_AT, MAX );				int pbPtr = lockedPointer();				setIntAt( NAMEPTR_AT, pbPtr + NAMEBUF_AT );				setIntAt( DTBUFPTR_AT, pbPtr + TEXTBUF_AT );				int osErr;				synchronized ( Toolbox.LOCK )				{  osErr = PBDTGetCommentSync( pbPtr );  }				if ( osErr == afpItemNotFound  ||  osErr == Errors.fnfErr  )					return ( text );				checkIOErr( osErr );				int len = getIntAt( DTACTUALCOUNT_AT );				if ( len > 0 )					text = getBytesAt( TEXTBUF_AT, len );			}			finally			{  unlock();  }//			Thread.yield();		}		return ( text );	}	/**	** Either set or remove the current target's comment-bytes,	** depending on the nature of text.  	** If text is null or zero-length, any existing comment is removed.	** If text is 1 or more bytes, the comment is set.	** Either case is followed by a flush.	**<p>	** The text is ordinary bytes, NOT a PStr.	*/	public void	writeComment( byte[] text )	  throws IOException	{		boolean setting = ( text != null  &&  text.length > 0 );		// If the DTRefNum is zero, then only pretend it worked.		if ( getShortAt( DTREFNUM_AT ) != 0 )		{			try			{				int len = 0;				if ( setting )				{					len = text.length;					if ( len > MAX )					{						len = MAX;						byte[] shorter = new byte[ len ];						System.arraycopy( text, 0, shorter, 0, len );						text = shorter;					}					setBytesAt( TEXTBUF_AT, text );				}				setIntAt( DTREQCOUNT_AT, len );				int pbPtr = lockedPointer();				setIntAt( NAMEPTR_AT, pbPtr + NAMEBUF_AT );				setIntAt( DTBUFPTR_AT, pbPtr + TEXTBUF_AT );						// The following could perhaps be done under one Toolbox.LOCK,				// but I didn't do it that way.  This is slower, perhaps, but less piggish.				int osErr;				synchronized ( Toolbox.LOCK )				{  osErr = ( setting ? PBDTSetCommentSync( pbPtr ) : PBDTRemoveCommentSync( pbPtr ) );  }				if ( ! setting  &&  (osErr == afpItemNotFound) )					osErr = 0;				checkIOErr( osErr ); 				synchronized ( Toolbox.LOCK )				{  osErr = PBDTFlushSync( pbPtr );  }				checkIOErr( osErr ); 			}			finally			{  unlock();  }//			Thread.yield();		}	}	/**	 * @param paramBlock	in C: <CODE>DTPBPtr paramBlock</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short PBDTGetPath(int paramBlock);	/**	 * @param paramBlock	in C: <CODE>DTPBPtr paramBlock</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short PBDTGetCommentSync(int paramBlock);	/**	 * @param paramBlock	in C: <CODE>DTPBPtr paramBlock</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short PBDTSetCommentSync(int paramBlock);	/**	 * @param paramBlock	in C: <CODE>DTPBPtr paramBlock</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short PBDTRemoveCommentSync(int paramBlock);	/**	 * @param paramBlock	in C: <CODE>DTPBPtr paramBlock</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short PBDTFlushSync(int paramBlock);}