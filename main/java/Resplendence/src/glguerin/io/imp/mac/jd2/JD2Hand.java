/*** Copyright 1998, 1999, 2001 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.jd2;import java.io.IOException;import com.apple.mrj.jdirect.*;import com.apple.mrj.macos.toolbox.Toolbox;import glguerin.io.imp.mac.*;// --- Revision History ---// 25Mar99 GLG  create// 12Apr99 GLG  change getSize() implementation to get real handle size// 13Apr99 GLG  add eraseAll()// 29Apr99 GLG  add Toolbox.LOCK code// 07Jun01 GLG  add checkIOErr() for sub-class reuse/**** A NewHandleStruct is a struct kept in a movable heap-handle, which can be locked** when one needs a pointer to the struct, then unlocked when done.** Examples of this usage can be found in CatalogAccessor and CommentAccessor.**<p>** Unlike its super-class, the int argument in the constructor is the size** of the handle you want to allocate, not a type-punned int representing an existing handle.** In short, this class allocates a new handle for you and manages it by itself.** Remember this by the "New" word in the class name.**<p>** My thanks to Mike Hall and Patrick Beard on the MRJ-dev mailing-list for telling** me how to dereference a handle to get the master-pointer.  In retrospect, it's obvious.** But then most genuine insights are that way, aren't they?**** @author Gregory Guerin*/public class JD2Hand  extends HandleStruct  implements com.apple.mrj.macos.libraries.InterfaceLib{	/**	** Used for getting master-pointer.	*/	private GenericPointer myRef;	/**	** Construct a new instance with a handle of the given size.	** Protected to remind you that this class is primarily for sub-classing.	*/	protected	JD2Hand( int size )	  throws MemoryException	{		super( 0 );		// a "nil" handle		// Here's one case where it's critical that we allocate the handle 		// AND retrieve MemError() in a single atomic operation or critical section.		int osErr;		synchronized ( Toolbox.LOCK )		{			handle = NewHandleClear( size );			osErr = MemError();		}		if ( osErr != 0 )		{			handle = 0;			throw new MemoryException( "MemError: " + osErr );		}		myRef = new GenericPointer( handle );	}	/**	** Check an I/O result-code.	*/	protected void	checkIOErr( int resultCode )	  throws IOException	{  Errors.checkIOError( resultCode, null, this );  }	/**	** Return the size of the underlying handle, or zero if the handle is null.	*/	public final int	getSize()	{		if ( handle == 0 )			return ( 0 );		synchronized ( Toolbox.LOCK )		{  return ( GetHandleSize( handle ) );  }	}	/**	** Erase the contents of the handle, i.e. zero the bytes in the block.	** We use an int-at-a-time algorithm if the block is an exact multiple of 4 bytes.	** I have no idea if this is really any faster than byte-at-a-time, but it's	** such a simple decision to make, I don't really care.	*/	protected void	eraseAll()	{		int len = getSize();		if ( (len & 3) == 0 )		{			// Use int-at-a-time algorithm.			for ( int at = 0;  at < len;  at += 4 )			{  setIntAt( at, 0 );  }		}		else		{			// Use byte-at-a-time algorithm.			for ( int at = 0;  at < len;  ++at )			{  setByteAt( at, (byte) 0 );  }		}	}	/**	** Lock the handle and return a pointer to the block,	** i.e. dereference the handle once.	*/	protected final int	lockedPointer()	  throws NullPointerException	{  		if ( handle == 0 )			throw new NullPointerException( "Null handle" );		synchronized ( Toolbox.LOCK )		{  HLock( handle );  }		return ( myRef.getIntAt( 0 ) );		// get the handle's master-pointer	}	/**	** Unlock the handle.	*/	protected final void	unlock()	{		if ( handle != 0 )		{			synchronized ( Toolbox.LOCK )			{  HUnlock( handle );  }		}	}	/**	** Discard the handle, along with other internal values.	*/	protected final void	dispose()	{		myRef = null;		int hand = handle;		handle = 0;		if ( hand != 0 )		{			synchronized ( Toolbox.LOCK )			{  DisposeHandle( hand );  }		}	}	/**	** Prepare to be GC'ed.	*/	protected void	finalize()	{  dispose();  }	/**	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short MemError();	/**	 * @param byteCount		in C: <CODE>Size byteCount</CODE>	 * @return				in C: <CODE>Handle </CODE>	 */	private static native int NewHandle(int byteCount);	/**	 * @param byteCount		in C: <CODE>Size byteCount</CODE>	 * @return				in C: <CODE>Handle </CODE>	 */	private static native int NewHandleClear(int byteCount);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 * @return				in C: <CODE>Size </CODE>	 */	private static native int GetHandleSize(int h);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 */	private static native void HLock(int h);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 */	private static native void HUnlock(int h);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 */	private static native void DisposeHandle(int h);}