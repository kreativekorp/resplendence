/*** Copyright 1998, 1999, 2001 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.jd1;import java.io.IOException;import com.apple.memory.*;import glguerin.io.imp.mac.*;// --- Revision History ---// 25Mar99 GLG  create// 13Apr99 GLG  add eraseAll()// 07Jun01 GLG  add checkIOErr() for sub-class reuse/**** A JD1Hand is a struct kept in a movable heap-handle, which can be locked** when one needs a pointer to the struct, then unlocked when done.** Examples of this usage can be found in CatalogAccessor and CommentAccessor.**<p>** Unlike its super-class, the int argument in the constructor is the size** of the handle you want to allocate, not a type-punned int representing an existing handle.** In short, this class allocates a new handle for you and manages it by itself.** Remember this by the "New" word in the class name.**<p>** My thanks to Mike Hall and Patrick Beard on the MRJ-dev mailing-list for telling** me how to dereference a handle to get the master-pointer.  In retrospect, it's obvious.** But then most genuine insights are that way, aren't they?**** @author Gregory Guerin*/public class JD1Hand  extends HandleObject  implements com.apple.NativeObject{	/**	** This version of method not in MemoryObject.	*/	public final void	setBytesAt( int offset, byte[] bytes )	{  setBytesAt( offset, bytes.length, bytes );  }	private PointerObject myRef;	/**	** Construct a new instance with a handle of the given size.	** Protected to remind you that this class is primarily for sub-classing.	*/	protected	JD1Hand( int size )	  throws MemoryException	{		super( NewHandleClear( size ) ); 		int osErr = MemError();		if ( osErr != 0 )		{			handle = 0;			throw new MemoryException( "MemError: " + osErr );		}		myRef = new PointerObject( handle, 4 );	}	/**	** Check an I/O result-code.	*/	protected void	checkIOErr( int resultCode )	  throws IOException	{  Errors.checkIOError( resultCode, null, this );  }	/**	** Return the size of the underlying handle, or zero if the handle is null.	*/	public final int	getSize()	{   return (  (handle != 0) ? GetHandleSize( handle ) : 0 );  }	/**	** Erase the contents of the handle, i.e. zero the bytes in the block.	*/	protected void	eraseAll()	{		int len = getSize();		if ( (len & 3) == 0 )		{			// Use int-at-a-time algorithm.			for ( int at = 0;  at < len;  at += 4 )			{  setIntAt( at, 0 );  }		}		else		{			// Use byte-at-a-time algorithm.			for ( int at = 0;  at < len;  ++at )			{  setByteAt( at, (byte) 0 );  }		}	}	/**	** Lock the handle and return a pointer to the block,	** i.e. dereference the handle once.	*/	protected final int	lockedPointer()	  throws NullPointerException	{  		if ( handle == 0 )			throw new NullPointerException( "Null handle" );		HLock( handle );		return ( myRef.getIntAt( 0 ) );		// derefence the handle's master-pointer	}	/**	** Unlock the handle.	*/	protected final void	unlock()	{		if ( handle != 0 )			HUnlock( handle );	}	/**	** Discard the handle, along with other internal values.	*/	protected final void	dispose()	{		myRef = null;		int hand = handle;		handle = 0;		if ( hand != 0 )			DisposeHandle( hand );	}	/**	** Prepare to be GC'ed.	*/	protected void	finalize()	{  dispose();  }	/**	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short MemError();	/**	 * @param byteCount		in C: <CODE>Size byteCount</CODE>	 * @return				in C: <CODE>Handle </CODE>	 */	private static native int NewHandle(int byteCount);	/**	 * @param byteCount		in C: <CODE>Size byteCount</CODE>	 * @return				in C: <CODE>Handle </CODE>	 */	private static native int NewHandleClear(int byteCount);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 * @return				in C: <CODE>Size </CODE>	 *///	private static native int GetHandleSize(int h);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 */	private static native void HLock(int h);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 */	private static native void HUnlock(int h);	/**	 * @param h				in C: <CODE>Handle h</CODE>	 */	private static native void DisposeHandle(int h);	private static String[] kNativeLibraryNames = { "InterfaceLib" };}