/*** Copyright 1998, 1999, 2001 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.jd2;import java.io.*;import com.apple.mrj.macos.toolbox.Toolbox;import glguerin.io.imp.mac.*;// --- Revision History ---// 24Mar99 GLG  first cut// 31Mar99 GLG  add resolve() methods that resolve aliases and set// 05Apr99 GLG  expand doc-comments// 12Apr99 GLG  move resolveEmbeddedAliases() here// 13Apr99 GLG  rework as extension of FSSpec class// 29Apr99 GLG  add Toolbox.LOCK code// 07May99 GLG  implement deleteMe()// 17May01 GLG  implement resolveMe()// 17May01 GLG  remove all old alias-resolving calls, leaving only resolveMe()// 12Jun01 GLG  add file-lock methods// 18Jun01 GLG  add createMe()/**** A JD2FSSpec is an FSSpec implementation that uses JDirect 2 in MRJ 2.1 or higher.**<p>** The Apple reference materials I used to make this class are:**<ul type="disc">**   <li> <i>Inside Macintosh: Files</i><br>**    Chapter 2 describes an FSSpec and the FSMakeFSSpec() function.**   </li>**   <li> <i>Inside Macintosh: Files</i>**    Chapter 4 is "Alias Manager". **   </li>**   <li> <i>Inside Macintosh: Macintosh Toolbox Essentials</i>**    Chapter 7 is "Finder Interface", **   ResolveAliasFile() is on p. 7-52. **   </li>**</ul>**** @author Gregory Guerin*/public final class JD2FSSpec  extends FSSpec  implements com.apple.mrj.macos.libraries.InterfaceLib{	/**	** Construct an empty FSSpec.	*/	public	JD2FSSpec()	{  super();  }	/**	** Create the item.	** Return an OSError value as the result.	** Does not change this FSSpec, which will still refer to the old location.	*/	protected int	createMe( int defaultType, int defaultCreator, boolean isDirectory )	{  		int osErr;		synchronized ( Toolbox.LOCK )		{			if ( isDirectory )				osErr = FSpDirCreate( getByteArray(), (short) -1, intRef );			else				osErr = FSpCreate( getByteArray(), defaultCreator, defaultType, (short) -1 );		}		return( osErr ); 	}	/**	** Open this item's designated fork.	** Return an OSError value as the result.	*/	protected int	openMe( boolean resFork, byte permission, short[] refNum )	{  		int osErr;		synchronized ( Toolbox.LOCK )		{			if ( resFork )				osErr = FSpOpenRF( getByteArray(), permission, refNum );			else				osErr = FSpOpenDF( getByteArray(), permission, refNum );		}		return( osErr ); 	}	/**	** Lock or unlock the file or directory referenced by the current FSSpec contents,	** without resolving any aliases.	** Return an OSError value as the result.	** Does not change this FSSpec, which will still refer to the old location.	*/	protected int	lockMe( boolean state )	{  		int osErr;		synchronized ( Toolbox.LOCK )		{  osErr = ( state ? FSpSetFLock( getByteArray() ) : FSpRstFLock( getByteArray() ) );  }		return( osErr ); 	}	/**	** Delete the file or directory referenced by the current FSSpec contents,	** without resolving any aliases.	** Return an OSError value as the result.	** The target must already exist (duh).	** If the target is a directory, it must be empty.	*/	protected int	deleteMe()	{		synchronized ( Toolbox.LOCK )		{  return ( FSpDelete( getByteArray() ) );  }	}	/**	** Rename the file or directory referenced by the current FSSpec contents,	** without resolving any aliases.	** Return an OSError value as the result.	** Does not change this FSSpec, which will still refer to the old name.	**<p>	** This method will typically be implemented by calling the function:<br>	**   FSpRename() from Chapter 2 of<br>	**   <i>Inside Macintosh: Files</i><br>	**   with the function itself located in <b>InterfaceLib</b>.	*/	protected int	renameMe( byte[] namePStr )	{		synchronized ( Toolbox.LOCK )		{  return ( FSpRename( getByteArray(), namePStr ) );  }	}	/**	** Move the file or directory referenced by the current FSSpec contents,	** without resolving any aliases.	** Return an OSError value as the result.	** Does not change this FSSpec, which will still refer to the old location.	**<p>	** This method will typically be implemented by calling the function:<br>	**   FSpCatMove() from Chapter 2 of<br>	**   <i>Inside Macintosh: Files</i><br>	**   with the function itself located in <b>InterfaceLib</b>.	*/	protected int	moveMe( byte[] destFSSpec )	{		synchronized ( Toolbox.LOCK )		{  return ( FSpCatMove( getByteArray(), destFSSpec ) );  }	}	/**	** Resolve the current FSSpec contents as a possible alias-file.	** Return an OSError value as the result.	**<p>	** This method will typically be implemented by calling the function:<br>	**   ResolveAliasFile() from Chapter 7 "Finder Interface" of<br>	**   <i>Inside Macintosh: Macintosh Toolbox Essentials</i><br>	**   with the function itself located in <b>InterfaceLib</b>.	*/	protected int	resolveMe( boolean resolveChains, byte[] targetIsFolder, byte[] wasAliased )	{		synchronized ( Toolbox.LOCK )		{  return ( ResolveAliasFile( getByteArray(), resolveChains, targetIsFolder, wasAliased ) );  }	}	/**	** Set this FSSpec from the given information.	*/	protected int	makeFSSpec( short vRefNum, int dirID, byte[] namePStr )	{  		int osErr;		synchronized ( Toolbox.LOCK )		{  osErr = FSMakeFSSpec( vRefNum, dirID, namePStr, getByteArray() );  }		return( osErr ); 	}	/**	 * @param vRefNum		in C: <CODE>short vRefNum</CODE>	 * @param dirID			in C: <CODE>long dirID</CODE>	 * @param fileName		in C: <CODE>ConstStr255Param fileName</CODE>	 * @param spec			in C: <CODE>FSSpec *spec</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	FSMakeFSSpec( short vRefNum, int dirID, byte[] fileName, byte[] spec );	/**	 * @param spec			in C: <CODE>FSSpec *spec</CODE>	 * @param isFolder			in C: <CODE>Boolean resolveChains</CODE>	 * @param isFolder			in C: <CODE>Boolean *isFolder</CODE>	 * @param hadAlias			in C: <CODE>Boolean *hadAlias</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	ResolveAliasFile( byte[] spec, boolean resolveChains, byte[] isFolder, byte[] hadAlias );	/** xx */	private static native short 	FSpCreate( byte[] fsSpec, int creator, int type, short scriptCode );	/** xx */	private static native short 	FSpDirCreate( byte[] fsSpec, short scriptCode, int[] dirRef );	/** xx */	private static native short 	FSpOpenDF( byte[] fsSpec, byte permission, short[] refNum );	/** xx */	private static native short 	FSpOpenRF( byte[] fsSpec, byte permission, short[] refNum );	/**	 * @param spec			in C: <CODE>const FSSpec *spec</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	FSpSetFLock(byte[] spec);	/**	 * @param spec			in C: <CODE>const FSSpec *spec</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	FSpRstFLock(byte[] spec);	/**	 * @param spec			in C: <CODE>const FSSpec *spec</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	FSpDelete(byte[] spec);	/**	 * @param spec			in C: <CODE>const FSSpec *spec</CODE>	 * @param newName		in C: <CODE>ConstStr255Param namePStr</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	FSpRename( byte[] spec, byte[] namePStr );	/**	 * @param source		in C: <CODE>const FSSpec *source</CODE>	 * @param dest			in C: <CODE>const FSSpec *dest</CODE>	 * @return				in C: <CODE>OSErr </CODE>	 */	private static native short 	FSpCatMove( byte[] source, byte[] dest );/* * * * *### Following is Java...	private static native short 	MakeResolvedFSSpec( short vol, int dir, byte[] nameStr255,				byte[] FSSpecPtr, byte[] isFolder, byte[] hadAlias, byte[] leafIsAlias );### Following is C...OSErr ResolveFolderAliases (	short volume, long directory, StringPtr path, Boolean resolveLeafAlias,	FSSpec *theSpec, Boolean *isFolder, Boolean *hadAlias, Boolean *leafIsAlias);OSErr MakeResolvedFSSpec (short volume, long directory, StringPtr path,						  FSSpec *theSpec, Boolean *isFolder, Boolean *hadAlias,						  Boolean *leafIsAlias);OSErr ResolvePath (char *rawPath, char *resolvedPath, Boolean *isFolder, Boolean *hadAlias);OSErr MakeResolvedPath (short volume, long directory, StringPtr path, Boolean resolveLeafAlias,						char *buffer, Boolean *isFolder, Boolean *hadAlias, Boolean *leafIsAlias);* * * * */}