/*** Copyright 2001, 2002, 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.ten;import java.io.*;import com.apple.mrj.macos.carbon.CarbonLock;import glguerin.io.*;import glguerin.io.imp.mac.*;// --- Revision History ---// 21Jun01 GLG  create first partial imp// 22Jun01 GLG  add more methods and more native-code bindings// 23Jun01 GLG  comment-out alias-resolving in refRoot()// 23Jun01 GLG  call FSIsAliasFile() in resolveRef() as qualifier before FSResolveAliasFile()// 27Jun01 GLG  add bootRef() and bootName(), and use on static bootItem// 04Jul01 GLG  cut boolean arg from refRoot()// 05Jul01 GLG  move some constants into superclass// 05Jul01 GLG  FIX: add neglected CarbonLock control to end()// 03Dec2002 GLG  FIX: embed literal Carbon framework-name here for Linker// 12Dec2002 GLG  add symlink-only Alias support (heck, it's better than nothing)// 13Dec2002 GLG  FIX: use FSResolveAliasFileWithMountFlags() instead of FSResolveAliasFile()// 02Jan2003 GLG  cover arg change to FSItem.newAlias()// 03Jan2003 GLG  refactor to extend FSRefItemX// 04Jan2003 GLG  add diagnostic inside newAlias()// 06Jan2003 GLG  revise for probeAppBundle() not throwing IOException// 16Jan2003 GLG  add mayResolve() imp that distinguishes symlinks// 18Jan2003 GLG  change mayResolve() to return T for any 'rhap'-creator alias-file// 24Jan2003 GLG  refactor bootName()// 11Feb2003 GLG  add informOfChange() with FNNotify() and FNNotifyAll()/**** A FSRefItem10 is an FSRefItem that uses the FSRef-based API under Mac OS X.**** @author Gregory Guerin*/public class FSRefItem10  extends FSRefItemX{    public static final String 		JDirect_MacOSX = "/System/Library/Frameworks/Carbon.framework/Versions/A/Carbon";	private static Object linkage = new com.apple.mrj.jdirect.Linker( FSRefItem10.class );	/**	** This FSRefItem10 is statically initialized by calling its refBoot() method,	** so the bootName() method will be able to always return the literalized boot-name.	** For example, if the user-visible "literal" name has an embedded slash like "R/W",	** the returned String would be "R/W", since that's what the FSRef APIs use.	*/	private static final FSRefItem10 bootItem;	static	{		bootItem = new FSRefItem10();		bootItem.refBoot();	}	/**	** Construct an empty FSRefItem.	*/	public	FSRefItem10()	{  super();  }	/**	** Concrete factory-method.	*/	protected ForkRW	newFork( boolean forWriting, int forkRefNum, String tag )	{  return ( new FSFork10( forWriting, forkRefNum, tag ) );  }	/**	** Set this FSItem so it references the boot volume, so that subsequent	** calls to bootName() return the literalized name of the boot volume.	**<p>	** This implementation works by leaving the volRefNum (technically, the FSVolumeRefNum)	** of the startup-volume in myRefNum[0].  The bootName() method then determines the	** name dynamically, returning it as a literalized String.  This may seem needlessly	** inefficient, but it's the only way to survive having the boot-volume's name changed.	** A little elapsed-timing shows that this isn't a significant time-sink	** in any case, so fears of squandered cycles are largely unfounded.	*/	protected void	refBoot()	{		final short STARTUP_VOL = (short) -32768;		final int SYSTEM_FOLDER = 0x6D616373;			// 'macs'		int[] dirDontCare = new int[ 1 ];		int osErr;		try		{			CarbonLock.acquire();			osErr = FindFolder( STARTUP_VOL, SYSTEM_FOLDER, false, myRefNum, dirDontCare );		}		finally		{  CarbonLock.release();  }		// Leave isReferenced indicating success/fail.		isReferenced = (osErr == 0);	}	/**	** Return the boot name, or throw an IOException.	** The user can edit the name of the boot volume at any time, which means we must	** always retrieve the name dynamically using the volRefNum established by bootRef().	*/	protected String	nameBoot()	  throws IOException	{		if ( ! isReferenced )			throw new IOException( "No boot name" );		int osErr;		try		{			CarbonLock.acquire();			osErr = FSGetVolumeInfo( myRefNum[ 0 ], 0, NULL, 0, NULL, myChars, myRef1 );			// Get the name of the specific volRefNum held in myRefNum[0].		}		finally		{  CarbonLock.release();  }		// If unsuccessful, signal failure.		if ( osErr != 0 )			throw new IOException( "Can't get boot name" );		// If successful, return literalized name via getName().		return ( getName() );	}	/**	** Return the boot name, or throw an IOException.	*/	protected String	bootName()	  throws IOException	{  return ( bootItem.nameBoot() );  }	/**	** Called by refPart(), which is called by refItem().	** On entry, myRef1 references an "apparent" directory, symlink, or alias-file.	** Return T if caller should attempt to resolve it, F if not.	**<p>	** An implementation of this method may use myRef1 but must not change it.	** It may use or change myRef2, and also myInfo, ignored[], and hadAlias[].	**<p>	** This imp returns T for symlinks ('slnk') and mounts ('lcmt').	** It returns F for all other kinds of files, even if they're alias-files.	** The actual test is just for alias-bit set and a creator-ID of 'rhap',	** which covers the known types ('slnk' and 'lcmt') and any types I don't know of.	** Overall, this is safer than requiring specific types, since it's better to have	** refParth() attempt resolving them than to not attempt it.	**<p>	** A symlink has alias-flag set, a file-type of 'slnk', and a creator of 'rhap'.	** It also has empty res-fork and non-empty data-fork.	**<p>	** A mount has alias-flag set, a file-type of  'lcmt', and a creator of 'rhap'.	** Both forks are empty, at least in all cases observed.	*/	protected boolean	mayResolve()	{		// Distinguish symlinks from alias-files using a FileInfo obtained for myRef1.		// The GETSET_FINFO form has core FinderInfo (flags, type, creator), but nothing else.		// A symlink has alias-flag set, a file-type of 'slnk', and a creator of 'rhap'.		// It also has empty res-fork and non-empty data-fork, which we don't check here.		// To avoid IOExceptions, call getRefInfo() directly.		// Failure means myRef1 is inaccessible for some reason.		if ( getRefInfo( myRef1, FSCatInfo.GETSET_FINFO, myInfo.getByteArray(), null, null ) == 0 )		{			// If myRef1's FileInfo indicates a symlink or a mount, caller should try to resolve it.			// Rather than look for specific file-types, accept any alias-file with 'rhap' as creator.			// If myRef1 is anything else, eventually returns F.			if ( myInfo.isAlias()  &&  myInfo.getFileCreator() == 0x72686170 )  // 'rhap'				return ( true );		}//		System.err.println( " * FSRefItem10.mayResolve(): false" );		// Getting here, tell caller not to resolve myRef1.		return ( false );	}	/**	** Create a new FileForker.Alias that refers to the current target	** as previously set by reference() and refItem(),	** or return null if Aliases are not supported.	** In general, the target must exist and be accessible, or an IOException is thrown.	**<p>	** The Pathname should contain the pathname of the current target.	** The Pathname must be a replica, since it may be assigned to the new Alias,	** or it may be manipulated during the Alias-making process.	**<p>	** This implementation makes SymAlias instances, which only support symlinks.	*/	public FileForker.Alias	newAlias( Pathname pathname )	  throws IOException	{		// Must refer to an existing file-system object, whose FSRef is in myRef1.		validAndRef();		// Make a FileInfo replica describing the current target (i.e. the "original referent").		// Must be the full form, not the brief form, since SymAlias needs file-type and creator.		FileInfo targetInfo = new BasicFileInfo( getInfo( true ) );		// By default, the SymAlias has no alias-specific FileInfo.		FileInfo aliasInfo = null;				// Preliminary check for an app-bundle should be fast, rejecting ordinary folders if possible.		// If it doesn't reject ordinary folders, the subsequent evaluation may be slower.		// The desired suffix for app-bundle folders is hard-wired.  Configurable might be nicer.		if ( possibleAppBundle( targetInfo, ".app" ) )		{			aliasInfo = probeAppBundle();			// Control diagnostic at compile-time with literal true or false.			if ( false  &&  aliasInfo != null )			{				System.err.println( " * FSRefItem10: " + pathname.last()						+ ", " + MacRoman.getOSTypeString( aliasInfo.getFileType() )						+ ", " + MacRoman.getOSTypeString( aliasInfo.getFileCreator() ) );				System.err.println( " *      probed: " + pathname );			}		}		// Getting here, make a SymAlias from Pathname and FileInfo's.		return ( new SymAlias( pathname.getPath(), targetInfo, aliasInfo ) );	}	/**	** Write the FileForker.Alias to the currently referenced target (as previously set).	** The target must not exist, but all elements leading up to it must exist.	** We detect that condition the same way FSRefItem.create() does: the isReferenced flag.	**<p>	** If the Alias isn't the correct type for the FSItem type, a ClassCastException is thrown.	** The Alias may be updated by this method, which may affect the Alias's pathname.	**<p>	** This imp only knows how to make symlinks.	*/	public boolean	writeAlias( boolean preferSymlink, Pathname targetPath, FileForker.Alias alias )	  throws IOException	{		// Must already be in the "FSRef plus name" state, not referencing the item directly,		// in order to attempt creating it.  Otherwise we surmise that it already exists.		// We don't support overwriting of alias-files, so an existing target is an error.		valid();		if ( isReferenced )			check( Errors.dupFNErr );		// throw an IOException with "file exists" text		// Any ClassCastException thrown here is caught by FSForker.createAliasFile().		// This imp only knows how to make symlinks.  On success, result is always a symlink: true.		SymAlias sim = (SymAlias) alias;		return ( sim.createSymlink( targetPath ) );	}// #####	/**	** Inform listeners that a referenced item changed, or that everything changed.	** Return T if a message was sent, F if not.	** This method is for implementing FileForker.signalChange().	**<p>	** This imp calls the static native method changed(),	** after selecting an FSRef byte-array to pass.	*/	public boolean	informOfChange( int messageValue, boolean specifically )	{		// Select which FSRef is passed to native method, or null if can't signal a change.		byte[] targetRef = whichFSRef( specifically );		if ( false )		{			String what = "null";			if ( targetRef != null )				what = (targetRef == myRef1 ? "myRef1" : "myRef2");			System.err.println( " * FSRefItem10.informOfChange(): " + what );		}		if ( targetRef == null )			return ( false );		// Getting here, we're ready to signal a change.		// Call either FNNotify() or FNNotifyAll().		// Result-code is not much use, so keep it but don't use it.		// Could let it determine returned boolean, but I'd rather indicate		// that the code ATTEMPTED to signal a change, so always return T.		int osErr;		try		{			CarbonLock.acquire();			if ( specifically )				osErr = FNNotify( targetRef, messageValue, 0 );  // 0 = kNilOptions			else				osErr = FNNotifyAll( messageValue, 0 );  // 0 = kNilOptions		}		finally		{  CarbonLock.release();  }		return ( true );	}// #####	/**	** Fill in the name and root FSRef of the indexed volume.	*/	protected int	volRef( int index, short[] volRefNum, char[] nameBuf, byte[] rootFSRef )	{		int osErr;		try		{			CarbonLock.acquire();			osErr = FSGetVolumeInfo( kFSInvalidVolumeRefNum, index, NULL,  0, NULL, nameBuf, rootFSRef );		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Make the resultFSRef refer to the given file or directory.	** Return an OSErr value as the result.	** None of the items may be null.	**<p>	** If the targeted item doesn't exist, an error-code is returned.	** Unlike with an FSSpec, an FSRef can't refer to a non-existent item.	** The rest of the code in FSRefItem is responsible for handling non-existent targets,	** so they can be encapsulated with behavior similar to a non-existent FSSpec.	*/	protected int	makeRef( byte[] parentFSRef, String name, byte[] resultFSRef )	{		// Do this before acquiring Carbon lock.		char[] chars = name.toCharArray();		int osErr;		try		{			CarbonLock.acquire();			osErr = FSMakeFSRefUnicode( parentFSRef, chars.length, chars, kTextEncodingUnknown, resultFSRef );				// textEncodingHint = kTextEncodingUnknown		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Resolve the given FSRef as a possible alias-file.	** Return an OSError value as the result.	**<p>	** See "Alias Manager" Carbon docs.	**<p>	** This imp calls FSIsAliasFile() before calling FSResolveAliasFile().	** Pre-qualifying theFSRef like this avoids difficulties in FSResolveAliasFile() that arise	** when the referenced item has a name that can't be represented in MacRoman.	** Despite the fact that the name is in UniCode, there's apparently something about	** alias-files that only accepts aliases in MacRoman.  The simplest example is probably	** the Icelandic 'thorn' character \u00FE.  Not only does this fail in FSResolveAliasFile(),	** but you can't even make an alias in Mac OS X Finder 10.0 to a file with a \u00FE in its name.	** The same applies to other characters: if it can't be represented in MacRoman, you can't	** make a Finder alias to it.	*/	protected int	resolveRef( byte[] theFSRef, boolean resolveChains, byte[] targetIsFolder, byte[] wasAliased )	{		int osErr;		try		{			CarbonLock.acquire();			osErr = FSIsAliasFile( theFSRef, wasAliased, targetIsFolder );					// N.B. positions of byte[] args are reversed from FSResolveAliasFile().			if ( osErr == 0  &&  wasAliased[ 0 ] != 0 )				osErr = FSResolveAliasFileWithMountFlags( theFSRef, true, targetIsFolder, wasAliased, 1 );					// the 1 arg is the flag for kResolveAliasFileNoUI.					// Apple's docs say FSResolveAliasFileWithMountFlags() is available in 10.0+.		}		finally		{  CarbonLock.release();  }		return ( osErr );	}		/**	** Get the FSCatalogInfo for theFSRef.	** Return an OSErr value as the result.	** The nameBuf or parentFSRef may be null.	*/	protected int	getRefInfo( byte[] theFSRef, int whichInfo, byte[] catInfo, char[] nameBuf, byte[] parentFSRef )	{		int osErr;		try		{			CarbonLock.acquire();			if ( nameBuf != null  &&  parentFSRef != null )				osErr = FSGetCatalogInfo( theFSRef, whichInfo, catInfo, nameBuf, NULL, parentFSRef );			else				osErr = FSGetCatalogInfo( theFSRef, whichInfo, catInfo, NULL, NULL, NULL );		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Set the FSCatalogInfo for theFSRef.	** Return an OSErr value as the result.	*/	protected int	setRefInfo( byte[] theFSRef, int whichInfo, byte[] catInfo )	{		int osErr;		try		{			CarbonLock.acquire();			osErr = FSSetCatalogInfo( theFSRef, whichInfo, catInfo );		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Create the file or directory referenced by the FSRef and other args.	** Return an OSErr value as the result.	** None of the items may be null.	*/	protected int	createRef( byte[] parentFSRef, String name, boolean isDirectory, byte[] resultFSRef )	{		char[] chars = name.toCharArray();		int osErr;		try		{			CarbonLock.acquire();			if ( isDirectory )				osErr = FSCreateDirectoryUnicode( parentFSRef, chars.length, chars,						0, NULL, resultFSRef, NULL, NULL );			else				osErr = FSCreateFileUnicode( parentFSRef, chars.length, chars,						0, NULL, resultFSRef, NULL );				// 0 = empty infoBitMap		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Delete the file or directory referenced by the FSRef,	** without resolving any aliases.	** Return an OSError value as the result.	*/	protected int	deleteRef( byte[] theFSRef )	{		int osErr;		try		{			CarbonLock.acquire();			osErr = FSDeleteObject( theFSRef );		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Move the file or directory referenced by the FSRef,	** without resolving any aliases.	** Return an OSError value as the result.	** The destination must reference an existing directory.	*/	protected int	moveRef( byte[] theFSRef, byte[] destinationFSRef )	{		int osErr;		try		{			CarbonLock.acquire();			osErr = FSMoveObject( theFSRef, destinationFSRef, NULL );		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Rename the file or directory referenced by the FSRef,	** without resolving any aliases.	** Return an OSError value as the result.	*/	protected int	renameRef( byte[] theFSRef, String newName, byte[] resultFSRef )	{		char[] chars = newName.toCharArray();		int osErr;		try		{			CarbonLock.acquire();			osErr = FSRenameUnicode( theFSRef, chars.length, chars, kTextEncodingUnknown, resultFSRef );				// text encoding hint = kTextEncodingUnknown		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Open the item's named fork.	** Return an OSError value as the result.	*/	protected int	openRef( byte[] theFSRef, char[] forkName, byte permissions, short[] refNum )	{		int osErr;		try		{			CarbonLock.acquire();			osErr = FSOpenFork( theFSRef, forkName.length, forkName, permissions, refNum );		}		finally		{  CarbonLock.release();  }		return ( osErr );	}	/**	** Return an opaque iterator Object for iterating over theFSRef.	** Returns an instance of IOException, appropriately prepared, if there was an error.	** Otherwise returns an instance of an arbitrary Object representing an iterator.	*/	protected Object	begin( byte[] theFSRef )	{		// The opaque Object is an int[2] array.		//   - array[0] is temporary storage for next() to use.		//   - array[1] holds the FSIterator itself.		int[] iteratorRef = new int[ 2 ];		int osErr;		try		{			CarbonLock.acquire();			osErr = FSOpenIterator( theFSRef, 0, iteratorRef );		}		finally		{  CarbonLock.release();  }		// If an error occurred, return an IOException instead of an opaque iterator Object.		try		{  check( osErr );  }		catch ( IOException why )		{  return ( why );  }		// Move the actual FSIterator into slot[1].		// This is so next() can use the array[0] slot to hold actual-count.		iteratorRef[ 1 ] = iteratorRef[ 0 ];		// Getting here, return the iteratorRef.		return ( iteratorRef );	}	/**	** Get the name of the next item iterated, or	** return null when nothing left to iterate.	** Errors also cause a null return, which simply halts the iteration.	**<p>	** The name must be a literalized (i.e. accent-composed) name, 	** suitable for adding directly to a Pathname.	**<p>	** Changes the contents of myInfo, myChars, and myRef2, which are 	** used calling FSGetCatalogInfoBulk() over the course of the iteration.	*/	protected String	next( Object iterator )	{		String result = null;		if ( iterator instanceof int[] )		{			// The int at array[1] is the actual FSIterator.			// We use the slot at array[0] to hold the actual-count returned in			// pointer-to-int passed to FSGetCatalogInfoBulk.  Yes, it's wacky,			// but since it's all opaque, so what?  And it's easier than making			// another int[] just to hold an int we don't really even care about.			int[] array = (int[]) iterator;			int osErr;			try			{				// All we really want is the name, so the GET_EXIST mask is more than adequate.				// Could even use zero for the mask, but what the heck.				// Use myRef2 as a temporary byte[] for containerChanged signal.				// It's visible, it's killable, it's available, so why not?				CarbonLock.acquire();				osErr = FSGetCatalogInfoBulk( array[ 1 ], 1, array, myRef2,						FSCatInfo.GET_EXIST, myInfo.getByteArray(), NULL, NULL, myChars );				// Could check whether array[0] is 1 (actual count) or 0 (no more items).				// Could check whether myRef2[0] is non-zero, indicating that container changed.			}			finally			{  CarbonLock.release();  }			// osErr: errFSNoMoreItems = -1417 indicates end of FSIterator			// Not that we distinguish it from any other errors.			// Since we used myChars as the name-buffer, getName() returns			// the appropriately literalized form of the name.			if ( osErr == 0 )				result = getName();		}		return ( result );	}	/**	** Stop iterating using the FSIterator started by begin().	*/	protected void	end( Object iterator )	{		if ( iterator instanceof int[] )		{			int[] array = (int[]) iterator;			try			{				CarbonLock.acquire();				FSCloseIterator( array[ 1 ] );					// don't care about any errors here.			}			finally			{  CarbonLock.release();  }			array[ 1 ] = 0;		}		return;	}	/**	** InterfaceLib 9.1+, CarbonLib 1.1+, Mac OS 10.0+	*/	private static native short 	FSIsAliasFile( byte[] theFSRef, byte[] wasAliased, byte[] targetIsFolder );	/**	** InterfaceLib 9.1+, CarbonLib 1.1+, Mac OS 10.0+	*/	private static native short 	FSResolveAliasFileWithMountFlags( byte[] theFSRef, boolean resolveChains,			byte[] targetIsFolder, byte[] wasAliased, int mountFlags );	/**	** InterfaceLib 7.1+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short	FindFolder( short vRefNum, int folderType, boolean create,			short[] foundVRefNum, int[] foundDirID );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSGetVolumeInfo( short volume, int index, int volRefNumPtr,			int infoBitMap, int infoPtr, char[] hfsUniStr255, byte[] rootFSRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSMakeFSRefUnicode( byte[] parentFSRef, int nameLen, char[] uniCharName,			int textEncodingHint, byte[] resultFSRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSGetCatalogInfo( byte[] theFSRef, int whichInfo, byte[] catInfo,			char[] outName, int noFSSpec, byte[] parentFSRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	** Same function as the other binding, but with 'int' args holding NULL (0).	** This is necessary because Java's 'null' reference is not equivalent to C's NULL.	*/	private static native short 	FSGetCatalogInfo( byte[] theFSRef, int whichInfo, byte[] catInfo,			 int noName, int noFSSpec, int noParentRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSSetCatalogInfo( byte[] theFSRef, int whichInfo, byte[] catInfo );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSCreateFileUnicode( byte[] parentFSRef, int nameLen, char[] uniCharName,			int infoBitMap, int infoPtr, byte[] resultFSRef, int nullFSSpec );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSCreateDirectoryUnicode( byte[] parentFSRef, int nameLen, char[] uniCharName,			int infoBitMap, int infoPtr, byte[] resultFSRef, int nullFSSpec, int uint32Ptr );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSDeleteObject( byte[] theFSRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSMoveObject( byte[] theFSRef, byte[] destFSRefDir, int nullNewFSRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSRenameUnicode( byte[] theFSRef, int nameLen, char[] uniCharName,			int textEncodingHint, byte[] resultFSRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSOpenFork( byte[] theFSRef, int nameLen, char[] forkName, byte permissions, short[] forkRefNum );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSOpenIterator( byte[] theFSRef, int iteratorFlags, int[] iteratorRef );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSGetCatalogInfoBulk( int fsIterator, int maxObj, int[] actual, byte[] containerChanged,			int whichInfo, byte[] catInfos, int noFSRefs, int noFSSpecs, char[] names );	/**	** InterfaceLib 9.0+, CarbonLib 1.0+, Mac OS 10.0+	*/	private static native short 	FSCloseIterator( int fsIterator );	/**	** InterfaceLib not, CarbonLib not, Mac OS 10.0+	*/	private static native short 	FNNotify( byte[] theFSRef, int message, int optionBits );	/**	** InterfaceLib not, CarbonLib not, Mac OS 10.0+	*/	private static native short 	FNNotifyAll( int message, int optionBits );}