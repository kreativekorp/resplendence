/*** Copyright 2002, 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.ten;import java.io.*;import glguerin.io.*;import glguerin.io.imp.mac.Errors;// --- Revision History ---// 12Dec2002 GLG  create, lifting pieces from ...macosx.TinAlias and Easy Posix Toolkit// 13Dec2002 GLG  add getCapabilities() imp// 01Jan2003 GLG  add always-false update()// 08Jan2003 GLG  add update() code to throw IOException after destroy()// 24Jan2003 GLG  cut update()/**** A SymAlias is only used to create symlinks, since it contains no AliasHandle.** Supporting AliasHandle's and real Finder-aliases is not simple, as the C native** code for MacOSXForker's TinAlias shows.**<p>** The internal representation of the original referent is purely a pathname String.** If the original referent is unavailable when FileForker.createAliasFile() is called,** an error will occur.**<p>** This class defines the core method to create symlinks.** I did it this way because symlink() is in the System framework, and FSRefItem10 is** already linking to the Carbon framework.  While multiple frameworks are possible in** JDirect-3, I didn't want to create the extra interfaces to do it for just one function.**** @author Gregory Guerin*/public final class SymAlias  extends FileForker.Alias{	public static final String		JDirect_MacOSX = "/System/Library/Frameworks/System.framework/System";	private static Object linkage = new com.apple.mrj.jdirect.Linker( SymAlias.class );	private String name;	private FileInfo targetInfo, aliasInfo;	/**	** Only constructor.  Not accessible outside package or subclasses.	** The FileInfo is always an unshared instance, which this Alias can keep and modify.	*/	protected	SymAlias( String originalName, FileInfo targetInfo, FileInfo aliasInfo )	{		super();		name = originalName;		this.targetInfo = targetInfo;		this.aliasInfo = aliasInfo;	}	/**	** Return the platform-dependent pathname of the original referent,	** in a form appropriate for a java.io.File or a suitably platform-aware Pathname.	** Initially, this is the value of getPath() of the FileForker at the time the	** Alias was made by makeAlias().	**<p>	** Returns null after destroy().	*/	public String	originalPath()	{  return ( name );  }	/**	** Return an identifying value representing the type of this Alias.	** The value may legitimately be zero, even when the implementation supports file-types.	** Certain specific values have meanings	** as described for the OSTYPE_XXX named constants in this class.	**<p>	** Returns -1 after destroy().	*/	public int	getAliasType()	{		// If aliasInfo was assigned, use its type and creator exactly as given.		if ( aliasInfo != null )			return ( aliasInfo.getFileType() );		// Getting here, we have to map original's info into an alias-type.		// If no targetInfo, return -1.		FileInfo info = targetInfo;		if ( info == null )			return ( -1 );		// Treat all originals that are directories as folders, never as bundles.		if ( info.isDirectory() )			return ( 0x66647270 );  // 'fdrp'		else if ( info.getFileType() == 0x4150504C )  // an 'APPL'-type file			return ( 0x61647270 );  // 'adrp'		// Otherwise, by default, alias-type is same type as original.		return ( info.getFileType() );	}	/**	** Return a set of bits, signifying capabilities, in an int.	**<p>	** This imp can only make symlinks, so return CAN_SYMLINK.	*/	public int	getCapabilities()	{  return ( CAN_SYMLINK );  }	/**	** Destroy all the internal elements of this Alias, making it unusable.	** Calling destroy() more than once on the same Alias is always harmless.	**<p>	** The number and kind of internal resources for an Alias is implementation-dependent.	** You can call this method to speed up the freeing of an Alias's internal resources.	** This would be wise if you're creating lots of Alias'es and the GC'er isn't working fast enough.	*/	public void	destroy()	{		name = null;		targetInfo = aliasInfo = null;	}	/**	** Return a NUL-terminated array of bytes equivalent to the "const char *" type	** that represents a pathname string to the POSIX calls.	** For Mac OS X, this means translating the pathname String into UTF-8	** and appending a NUL byte.	** If the given name is null or empty, a FileNotFoundException is thrown.	*/	protected byte[]	getNameBytes( String name )	  throws IOException	{		if ( name == null  ||  name.length() == 0 )			throw new FileNotFoundException( "Empty filename" );		byte[] bytes = name.getBytes( "UTF8" );		byte[] result = new byte[ bytes.length + 1 ];		System.arraycopy( bytes, 0, result, 0, bytes.length );			// the result array is initially filled with NUL's, so we don't have to append one.		return ( result );	}	/**	** Called after FSRefItem10.writeAlias() does setup and other preliminaries.	** This SymAlias already knows the original's pathname.	**<p>	** This method always returns T, indicating a symlink was created.	** It never returns F, since it can't create Finder-aliases.	** All failures throw an IOException.	*/	protected boolean	createSymlink( Pathname targetPath )	  throws IOException	{		String original = originalPath();		needs( original );		// Get UTF-8 form of both names, as nul-terminated C-strings in byte-arrays.		byte[] originalBytes = getNameBytes( original );		byte[] targetBytes = getNameBytes( targetPath.getPath() );		// The native method returns an errno value, not an OSError value.		// In order to have Errors.checkIOError() work, we have to translate the errno-codes.		int errno = symlink( originalBytes, targetBytes );		if ( errno != 0 )		{			// Only bother translating a few of the most important errno codes.			if ( errno == 2 )  // ENOENT				errno = Errors.fnfErr;			else if ( errno == 17 )  // EEXIST				errno = Errors.dupFNErr;			else if ( errno == 20 )  // ENOTDIR				errno = Errors.errFSNotAFolder;			// checkIOError() always throws an IOException when errno is non-zero.			Errors.checkIOError( errno, "Can't create symlink: ", targetPath.getPath() );		}		// Boolean true signifies "symlink created", not "success".		return ( true );	}	/**	** This method is synchronized because I don't know how re-entrant symlink() is.	** Both names are UTF-8, nul-terminated C strings.	**	 * @param name1		in C: <CODE>const char * name1</CODE>; the original file	 * @param name2		in C: <CODE>const char * name2</CODE>; the symlink to create	 * @return				in C: <CODE>int </CODE>	 */	private static synchronized native int		symlink( byte[] name1, byte[] name2 );}