/*** Copyright 2001 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.jd2;import java.io.*;import com.apple.mrj.macos.toolbox.Toolbox;import com.apple.mrj.internal.jdirect.TerminationListener;import com.apple.mrj.internal.jdirect.TerminationServices;import glguerin.io.*;import glguerin.io.imp.mac.*;// --- Revision History ---// 05Jul01 GLG  create by diverging from FSFork10/**** FSFork9 is a ForkRW that uses the FSRef APIs from InterfaceLib on Mac OS 9.**<p>** I'm not sure whether forks must be closed manually at termination.** I'm doing it anyway because it just seems safer that way.**** @author Gregory Guerin*/public final class FSFork9  extends ForkRW  implements TerminationListener, com.apple.mrj.macos.libraries.InterfaceLib{	/**	** Only constructor.	*/	public	FSFork9( boolean forWriting, int forkRefNum, String tag )	{		super( forWriting, forkRefNum, tag );		TerminationServices.addListener( this );	}	/**	** As a TerminationListener, this method closes the fork using forceClose().	** This instance is added as a listener when it's opened successfully, then	** removed as a listener after closing.  Thus, the only listeners that remain at exit()	** are the ones still having open forks.	*/	public void 	terminate()	{		try		{  forceClose();  }		catch ( IOException why )		{ /* IGNORED */ }	}	/**	** Flush anything internally buffered to disk.	*/	public void 	flush()	  throws IOException	{		short refNum = refOK();		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSFlushFork( refNum );		}		checkIO( osErr );	}	/**	** Return the length of the given refNum's fork, or throw an IOException.	*/	protected int	forkLength( short refNum, long[] length )	{		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSGetForkSize( refNum, length );		}		return ( osErr );	}	/**	** Return the current R/W position of the given refNum's fork, or throw an IOException.	*/	protected int	forkAt( short refNum, long[] position )	{		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSGetForkPosition( refNum, position );		}		return ( osErr );	}	/**	** Seek to the given position in the given refNum's fork, or throw an IOException.	** The position is always relative to the beginning of the file.	*/	protected int	forkSeek( short refNum, long position )	{		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSSetForkPosition( refNum, (short) 1, position );				// posMode 1 = fsFromStart		}		return ( osErr ); 	}	/**	** Set the length of the given refNum's fork, or throw an IOException.	** When extended, the new bytes in the fork may contain arbitrary	** and possibly sensitive data from reused disk blocks.	*/	protected int	forkSetLength( short refNum, long length )	{		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSSetForkSize( refNum, (short) 1, length );				// posMode 1 = fsFromStart		}		return ( osErr ); 	}	/**	** Read bytes from the current position in the given refNum's fork,	** for a byte-count given by requestCount, placing the bytes in the buffer	** beginning at offset 0.	** Return the actual byte-count read in actualCount[ 0 ].	*/	protected int	forkRead( short refNum, byte[] buffer, int requestCount, int[] actualCount )	{		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSReadFork( refNum, (short) 0, 0L, requestCount, buffer, actualCount );				// posMode 0 = kFSAtMark, offset 0L = ignored.		}		return ( osErr ); 	}	/**	** Write bytes to the current position in the given refNum's fork,	** for a byte-count given by requestCount, taking the bytes from the buffer	** beginning at offset 0.	*/	protected int	forkWrite( short refNum, byte[] buffer, int requestCount, int[] actualCount )	{  //		actualCount[ 0 ] = requestCount;		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSWriteFork( refNum, (short) 0, 0L, requestCount, buffer, actualCount );				// posMode 0 = kFSAtMark, offset 0L = ignored.		}		return ( osErr ); 	}	/**	** Close the given refNum.	*/	protected int	forkClose( short refNum )	{  		int osErr;		synchronized ( Toolbox.LOCK )		{			osErr = FSCloseFork( refNum );		}		TerminationServices.removeListener( this );		return ( osErr ); 	 }	// ###  J D I R E C T - 2   F U N C T I O N   B I N D I N G S  ###	/** xx */	private static native short 	FSFlushFork( short refNum );	/** xx */	private static native short 	FSCloseFork( short refNum );	/** xx */	private static native short 	FSReadFork( short refNum, short posMode, long offset, int request, byte[] buffer, int[] got );	/** xx */	private static native short 	FSWriteFork( short refNum, short posMode, long offset, int request, byte[] buffer, int[] got );	/** xx */	private static native short 	FSGetForkSize( short refNum, long[] longRef );	/** xx */	private static native short 	FSSetForkSize( short refNum, short posMode, long position );	/** xx */	private static native short 	FSGetForkPosition( short refNum, long[] longRef );	/** xx */	private static native short 	FSSetForkPosition( short refNum, short posMode, long position );}