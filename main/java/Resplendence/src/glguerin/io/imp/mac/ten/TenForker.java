/*** Copyright 2001, 2002, 2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>** This file is from the MacBinary Toolkit for Java:**   <http://www.amug.org/~glguerin/sw/#macbinary> */package glguerin.io.imp.mac.ten;import java.io.*;import glguerin.io.*;import glguerin.io.imp.mac.*;// --- Revision History ---// 22Jun01 GLG  create// 12Dec2002 GLG  lift isSymlink() and makeAliasInfo() imps from ...macosx.MacOSXForker// 01Jan2003 GLG  refactor makeAliasInfo() to call isAppBundleName()// 03Jan2003 GLG  move all Alias-making code to FSRefItem10 and SymAlias// 16Jan2003 GLG  FIX: isHidden() now handles "/" pathnames without NullPointerException// 11Feb2003 GLG  add signalChange()/**** A TenForker is an implementation of FileForker for Mac OS X 10.0 or higher.** It relies on JDirect-3 for native-code calls,** providing long UniCode names, forks beyond 2 GB, and full Unix-style FileAccess privileges.** This imp is not usable in Cocoa-Java programs, because JDirect-3 is incompatible with Cocoa-Java.**<p>** For historical reasons, TenForker resolves non-leaf symlinks on-the-fly,** but does not resolve non-leaf alias-files on-the-fly.** Use ResolvingTenForker if you want to resolve non-leaf symlinks AND alias-files on-the-fly**<p>** TenForker provides an isSymlink() implementation that distinguishes symlinks from** other kinds of alias-files.**<p>** TenForker provides a simple implementation of FileForker.Alias**  thatis only capable of creating symlinks.  It can't create Finder-style alias-files.** Although this simple Alias is unable to create Finder-style alias-files,** TenForker is still able to resolve both Finder-aliases and symlinks.**<p>** TenForker provides a signalChange() method that can signal changes to folders,** files, and some non-existent files.  Plain files and non-existent files actually** signal a change on the immediately enclosing directory.** TenForker does not provide a Watcher implementation.**** @author Gregory Guerin**** @see ResolvingTenForker** @see FSFork10** @see FSRefItem10*/public class TenForker  extends FSForker{	/**	** Vanilla constructor.	*/	public	TenForker()	{  		super();  	}	/** Make a concrete FSItem. */	protected FSItem	newFSItem()	{  return ( new FSRefItem10() );  }	/**	** Return true if the current target is a symlink, false if not.	**<p>	** This imp identifies symlinks by examining the FileInfo of the target.	** On Mac OS X (tested on 10.1 or later) a symlink appears to the FSRef-based	** code as a file with the following characteristics:	**<ul>	**  <li>Finder-flags indicate isAlias</li>	**  <li>data-fork length non-zero</li>	**  <li>resource-fork length zero</li>	**  <li>file-type of 'slnk' 0x736C6E6B</li>	**  <li>creator of 'rhap' 0x72686170</li>	**</ul>	** These characteristics even appear for symlinks on a UFS volume	** that has no other Mac OS metadata.	*/	public boolean	isSymlink()	{		try		{			// The FileInfo must have file-type and creator, also fork-lengths,			// so the brief FSItem.getInfo() form won't do.			FileInfo info = target( false, false ).getInfo( true );			if ( info.isAlias()  &&  info.getForkLength( false ) > 0					&&  info.getForkLength( true ) == 0					&&  info.getFileType() == 0x736C6E6B  // 'slnk'					&&  info.getFileCreator() == 0x72686170 )  // 'rhap'			{  return ( true );  }		}		catch ( IOException why )		{  /* FALL THROUGH */  }		return ( false );	}	/**	** On Mac OS X, all names starting with "." are nornally hidden.	** This should be enforced regardless of whether the item has the INVISIBLE Finder-flag set or not.	*/	public boolean	isHidden()	{		if ( super.isHidden() )			return ( true );		// Handles an empty Pathname, representing "/".		// Although "/" is visible, "/." and "/.." are invisible.		String leaf = getLeafName();		return ( leaf != null  &&  leaf.startsWith( "." ) );	}	private static int fileType = 0;	private static int fileCreator = 0;	/**	** Set the creator and file types that newly created files will have by default.	** Calling this method on any concrete FileForker instance sets the defaults for	** all concrete instances of the same class.	**<p>	** In this implementation, the built-in defaults are both set to 0,	** which is the most sensible thing to do on Mac OS X.	*/	public void	setDefaultTypes( int defaultFileType, int defaultFileCreator )	{		fileType = defaultFileType;		fileCreator = defaultFileCreator;	}	/**	** Called by makeForkOutputStream() and makeForkRandomRW(),	** or anywhere else a file needs to be created.  NOT called when an existing	** file is merely truncated.	*/	public int	getDefaultFileType()	{  return ( fileType );  }	/**	** Called by makeForkOutputStream() and makeForkRandomRW(),	** or anywhere else a file needs to be created.  NOT called when an existing	** file is merely truncated.	*/	public int	getDefaultFileCreator()	{  return ( fileCreator );  }	/**	** If possible, signal any change-watchers that the current target or its contents have changed.	** Interested watchers should then re-examine the item or its contents,	** or perform some other watcher-specific action.	** The change-watchers may be in the current process, or in other processes,	** or maybe even on other machines.	** The propagation distance of the change signal is implementation-specific.	**<p>	** This method returns T if a signal was sent (not necessarily a Unix-like signal),	** or it returns F if no signal was sent or the feature is unimplemented.	** This method takes a boolean arg that defines the intended scope of the change.	** Pass T to signal change-watchers that the specific target has changed.	** Pass F to signal change-watchers that all displayed file-system items may have changed.	**<p>	** This imp defers to the underlying FSItem.	** When 'specifically' is T, the target may be an existing file or directory,	** or a non-existing leaf in an existing directory.	** When the target is an existing directory, the change-signal refers to that directory.	** When the target is an existing file, the change-signal refers to the file's parent directory.	** The same is true for a non-existing leaf: the parent directory is the effective target.	** This imp returns F only when an attempt to send the signal couldn't be made at all,	** for example, if a non-leaf named directory is inaccessible.	*/	public boolean	signalChange( boolean specifically )	{		// Initially, refer to nothing.  This is for the non-specifically case.		myRef.invalid();		// If a specific target is requested, it must be referenceable.		// The FSItem is responsible for deciding what informOfChange()		// does when the target is a file, or a directory, or doesn't exist.		// The FSForker is only responsible for pointing the FSItem at		// some Pathname'd item.		if ( specifically )		{			// Point myRef at a specific Pathname'd item.			// If that fails, return F immediately.			try			{  target( false, false );  }			catch ( IOException why )			{  return ( false );  }		}		// According to the docs for FNNotify().		final int kFNDirectoryModifiedMessage = 1;		// At this point, myRef is either still invalid, or it refers to something.		// Let informOfChange() sort it all out.		return ( myRef.informOfChange( kFNDirectoryModifiedMessage, specifically ) );	}}