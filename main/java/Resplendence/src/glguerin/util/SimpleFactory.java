/*** Copyright 1998-2003 by Gregory L. Guerin.** Terms of use:**  - Briefly: OPEN SOURCE under Artistic License -- credit fairly, use freely, alter carefully.**  - Fully: <http://www.amug.org/~glguerin/sw/artistic-license.html>*/package glguerin.util;// --- Revision History ---// 05Jun2003 GLG  factor out of other classes// 06Jun2003 GLG  rework to throw SimpleFactory.Failure, an IllegalArgumentException/**** A SimpleFactory is a simple representation of the Factory pattern.** It's simple because it requires the actual factory-Class to have a default** no-args public constructor as its principal instance-making mechanism.** That is, the factory Class must be instantiable via Class.newInstance().**<p>** In other respects, a SimpleFactory is fairly sophisticated, because it can optionally** ensure that instances manufactured by the factory Class are of a particular type.** This is accomplished using an optional archetypal Class provided in the constructor,** which is immutable (but retrievable) thereafter.**<p>** A SimpleFactory is not inherently thread-safe.** This is intentional.** If you need thread-safety, you must provide it externally.** There are several ways to accomplish this, and only you can decide which is best.**** @author Gregory Guerin*/public class SimpleFactory{	/**	** SimpleFactory.Failure is an IllegalArgumentException subclass	** thrown by SimpleFactory methods on all kinds of failures.	** It is an unchecked RuntimeException, so need not be declared with 'throws'.	*/	public static class Failure	  extends IllegalArgumentException	{		/**		 * 		 */		private static final long serialVersionUID = -2214135696289390831L;		/** The only constructor is the one with message text. */		public Failure( String message )		{  super( message );  }	}	/**	** The factory Class.	** Set by setFactory() and setFactoryClass(), used by makeOne().	*/	private Class<?> myFactory;	/**	** The optional archetypal Class, which may be null.	** Primarily used by makeOne(), to check the type of the factory-made instance.	** Also used by setFactory() and setFactoryClass(), to check that any Class	** assigned as the factory is of an assignable type.	*/	private final Class<?> myArchetype;	/**	** Create with given archetype Class, which may be null.	** If the archetype is null, then no enforcement of type is done	** on factory-made instances.	**<p>	** The factory Class is initially null (empty).	** A factory Class must be assigned with setFactoryClass() before	** any calls to makeOne() will succeed.	** If a non-null archetype Class is provided, then the factory Class	** must be a subclass or implementation of the archetype.	**<p>	** The archetype Class may represent an interface or an abstract class.	** It need not have a public constructor, nor be instantiable (concrete).	**<p>	** The archetype Class is only settable in the constructor.	** If you have a factory whose archetype changes, it's no longer a simple factory.	*/	public	SimpleFactory( Class<?> archetype )	{		myArchetype = archetype;	}	/**	** Return the current factory Class, or null.	** This represents the specific Class of instances returned by makeOne().	** Since it represents concrete instances, it is not abstract, nor an interface.	** Furthermore, since a SimpleFactory only works with classes having public	** no-args constructors, you can be certain that newInstance() works on it,	** otherwise it would not have been accepted by setFactory() or setFactoryClass().	*/	public Class<?>	getFactoryClass()	{  return ( myFactory );  }	/**	** Return the assigned archetypal Class, or null if no archetype is assigned or enforced.	** An archetypal Class represents a type-enforced super-Class for instances returned by makeOne().	** Thus, a non-null archetypal Class determines what superclass type makeOne()	** will return by enforcing the factory-Class to be assignable to an archetypal variable.	** That is, all instances returned by makeOne() will be of a type identical to or descended	** from the archetypal Class.  Furthermore, setFactoryClass() will only accept a factory Class	** identical to or descended from the archetypal Class.	**<p>	** The returned archetypal Class may represent an interface or an abstract class.	** It may not be instantiable, such as by newInstance() or any other constructor form.	**<p>	** An archetypal Class can only be assigned in the SimpleFactory constructor.	** If the archetypal Class is null, then makeOne() does not enforce any assignable type	** on the instances it makes with the factory Class.	*/	public Class<?>	getArchetypalClass()	{  return ( myArchetype );  }	/**	** Set the factory to the given Class, which may be null,	** returning any trial "first instance" created, or returning null for a null factory.	** If the given Class is unacceptable or unusable, a SimpleFactory.Failure is thrown,	** and the currently assigned factory Class is unchanged.	**	** @exception SimpleFactory.Failure	**   thrown when any error occurs.	*/	public Object	setFactoryClass( Class<?> factory )//	  throws SimpleFactory.Failure	{		if ( factory == null )		{  return ( myFactory = null );  }		// The simplest way to test the desired factory Class is a trial instantiation.		// We must return any trial instance on success.		Object trial = makeWith( factory, myArchetype );		myFactory = factory;		return ( trial );	}	/**	** Set the factory to be the given fully-qualified class name, or to null,	** returning any trial "first instance" created, or null if no factory assigned.	** If the className is null or empty, the factory is set to null without causing an error.	** Otherwise the className must name a viable and instantiable Class of the correct type.	**	** @exception SimpleFactory.Failure	**   thrown when any error occurs.	*/	public Object	setFactory( String className )//	  throws SimpleFactory.Failure	{		if ( className == null  ||  className.length() == 0 )		{			myFactory = null;			return ( null );		}		String reason = "Unknown error ";		// If any exceptions are thrown, myFactory must end up null.		try		{			// If this works, then myFactory is acceptable and valid, so keep it.			return ( setFactoryClass( Class.forName( className ) ) );		}		catch ( SimpleFactory.Failure why )		{			// Force factory to null, then rethrow the exception.			myFactory = null;			throw why;		}		catch ( ClassNotFoundException why )		{  reason = "Class not found: ";  }		catch ( Throwable why )		{  reason = "Can't set factory: caught " + why.getClass().getName() + ": " + why.getMessage() + ": ";  }		// Getting here, the factory Class doesn't work, so it must be set to null.		myFactory = null;		throw new Failure( reason + String.valueOf( className ) );	}	/**	** Make a new instance using the current factory Class, also ensuring it	** is assignable to a variable of the same type as the archetypal Class.	**<p>	** If no factory has ever been set,	** or the instance doesn't match the archetype,	** or any other failures occur,	** a SimpleFactory.Failure is thrown.	** You should arrange to catch this exception.	** If you don't, your program will terminate abruptly.	**	** @exception SimpleFactory.Failure	**   thrown when any error occurs.	**	** @see #setFactory	** @see #setFactoryClass	** @see #getFactoryClass	** @see #getArchetypalClass	*/	public Object	makeOne()//	  throws SimpleFactory.Failure	{  return ( makeWith( getFactoryClass(), getArchetypalClass() ) );  }	/**	** Make a new instance using the given factory and archetype Classes.	** All failures throw a SimpleFactory.Failure.	**	** @exception SimpleFactory.Failure	**   thrown when any error occurs.	**	** @see #setFactoryClass	** @see #makeOne	*/	protected Object	makeWith( Class<?> factory, Class<?> archetype )//	  throws SimpleFactory.Failure	{		if ( factory == null )			throw new Failure( "Null factory Class" );		String reason = "";		try		{			// If can't make an instance, the factory has failed.			Object instance = factory.newInstance();			// If instance is compatible with archetypal Class, return it.			if ( archetype == null  ||  archetype.isInstance( instance ) )				return ( instance );			// Getting here, instance is not archetypal, so failure is in instance's type.			reason = "Not an instance of " + archetype.getClass() + ": ";			// End by falling through to throw a Failure.		}//		catch ( NoSuchMethodException why )//		{  reason = "No default constructor: ";  }		catch ( InstantiationException why )		{  reason = "Can't be abstract: ";  }		catch ( IllegalAccessException why )		{  reason = "No public constructor(): ";  }		catch ( Throwable why )		{  reason = "Can't use factory: caught " + why.getClass().getName() + ": " + why.getMessage() + ": ";  }		throw new Failure( reason + String.valueOf( factory ) );	}}